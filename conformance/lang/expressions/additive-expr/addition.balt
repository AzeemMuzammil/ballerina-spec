Test-Case: error
Description: Test invalid concatenation with string.
Labels: additive-expr, string, int, nil-type, array-type

function testFunction(string a, int b, () c, string[] d) {
    string _ = a + b; // @error cannot concatenate string and int
    string _ = a + c; // @error cannot concatenate string and nil
    string _ = a + d; // @error cannot concatenate string and array
    string _ = b + a + a; // @error cannot concatenate string and int
    string _ = c + a; // @error cannot concatenate string and nil
    string _ = d + a; // @error cannot concatenate string and array
}

Test-Case: error
Description: Test invalid static type of string concatenation.
Labels: additive-expr, string, int

function testFunction(string a, string b) {
    int _ = a + b; // @error static type of string concatenation is string
    int _ = a + b + a; // @error static type of string concatenation is string
}

Test-Case: error
Description: Test invalid static type of string concatenation with string:Char.
Labels: additive-expr, string, int, string:Char

function testFunction(string a, string:Char b) {
    int _ = a + b; // @error static type of string concatenation is string
    string:Char _ = b + b; // @error static type of string concatenation is string
    string:Char _ = b + a; // @error static type of string concatenation is string
    string:Char _ = b + a + a; // @error static type of string concatenation is string
}

Test-Case: error
Description: Test invalid static type of user-defined string subtype concatenation with string and string:Char.
Labels: additive-expr, string, int, string:Char, module-type-defn, union-type

type Strings "A"|"foo";
type Chars "A"|"B";

function testFunction(string a, string:Char b, Strings c, Chars d) {
    Strings _ = a + c; // @error static type of string concatenation is string
    Strings _ = b + c; // @error static type of string concatenation is string
    string:Char _ = d + c; // @error static type of string concatenation is string
    int _ = c + a; // @error static type of string concatenation is string
    string:Char _i = c + b; // @error static type of string concatenation is string
    Strings _ = c + d; // @error static type of string concatenation is string
    Strings _ = c + c; // @error static type of string concatenation is string
    Chars _ = a + d; // @error static type of string concatenation is string
    Chars _ = b + d; // @error static type of string concatenation is string
    int _ = d + a; // @error static type of string concatenation is string
    string:Char _ = d + b; // @error static type of string concatenation is string
    Chars _ = d + d; // @error static type of string concatenation is string
    Chars _ = d + d + d; // @error static type of string concatenation is string
}

Test-Case: error
Description: Test invalid optional string concatenation.
Labels: additive-expr, string, optional-type

function testFunction(string? a, string? b, string c) {
    string _ = a + b; // @error cannot concatenate optional strings
    string? _ = a + b; // @error cannot concatenate optional strings
    string _ = a + c; // @error cannot concatenate string and optional string
    string _ = c + a + c; // @error cannot concatenate string and optional string
}

Test-Case: error
Description: Test invalid optional string:Char concatenation.
Labels: additive-expr, string, string:Char, optional-type

function testFunction(string:Char? a, string:Char? b, string:Char c) {
    string:Char _ = a + b; // @error cannot concatenate optional strings
    string:Char? _ = a + b; // @error cannot concatenate optional strings
    string:Char _ = a + c; // @error cannot concatenate string and optional string
    string:Char _ = a + a + c + c; // @error cannot concatenate string and optional string
}

Test-Case: error
Description: Test invalid optional user-defined string type concatenation.
Labels: additive-expr, string, string:Char, optional-type

type Strings "a"|"bc";

function testFunction(Strings? a, Strings? b, Strings c) {
    Strings _ = a + b; // @error cannot concatenate optional strings
    Strings? _ = a + b; // @error cannot concatenate optional strings
    Strings _ = a + c; // @error cannot concatenate string and optional string
    Strings _ = a + c + b; // @error cannot concatenate string and optional string
}

Test-Case: error
Description: Test string concatenation static type via invalid assignment with var.
Labels: additive-expr, string, string:Char, int, union-type, module-type-defn, var

type Strings "a"|"bc";

function testFunction(string a, string:Char b, Strings c) {
    var d = a + a;
    int v1 = d; // @error incompatible types: expected int found string
    string:Char v2 = d; // @error incompatible types: expected string:Char found string

    var e = a + b;
    v1 = e; // @error incompatible types: expected int found string
    v2 = e; // @error incompatible types: expected string:Char found string

    var f = a + c;
    v1 = f; // @error incompatible types: expected int found string
    v2 = f; // @error incompatible types: expected string:Char found string

    var g = b + a;
    v1 = g; // @error incompatible types: expected int found string
    v2 = g; // @error incompatible types: expected string:Char found string

    var h = b + b;
    v1 = h; // @error incompatible types: expected int found string
    v2 = h; // @error incompatible types: expected string:Char found string

    var i = b + c;
    v1 = i; // @error incompatible types: expected int found string
    v2 = i; // @error incompatible types: expected string:Char found string

    var j = c + a;
    v1 = j; // @error incompatible types: expected int found string
    v2 = j; // @error incompatible types: expected string:Char found string

    var k = c + b;
    v1 = k; // @error incompatible types: expected int found string
    v2 = k; // @error incompatible types: expected string:Char found string

    var l = c + c;
    v1 = l; // @error incompatible types: expected int found string
    v2 = l; // @error incompatible types: expected string:Char found string
}

Test-Case: output
Description: Test string concatenation.
Labels: additive-expr, string, value:toBalString

function init() {
    string a = "";
    string b = "hello ";
    string c = " world";
    string d = " from ballerina ";

    string s = a + a;
    printString(s); // @output ""
    printString(a + b); // @output "hello "
    printString(a + c); // @output " world"
    printString(a + d); // @output " from ballerina "

    printString(b + a); // @output "hello "
    printString(b + b); // @output "hello hello "
    printString(b + c); // @output "hello  world"
    printString(b + d); // @output "hello  from ballerina "

    printString(c + a); // @output " world"
    printString(c + b); // @output " worldhello "
    printString(c + c); // @output " world world"
    printString(c + d); // @output " world from ballerina "

    printString(d + a); // @output " from ballerina "
    printString(d + b); // @output " from ballerina hello "
    printString(d + c); // @output " from ballerina  world"
    printString(d + d); // @output " from ballerina  from ballerina "
}

function printString(string s) {
    io:println(s.toBalString());
}

Test-Case: output
Description: Test string concatenation with string:Char.
Labels: additive-expr, string, string:Char, value:toBalString

function init() {
    string:Char a = "_";
    string:Char b = "x";
    string:Char c = " ";
    string:Char d = "y";

    string s = a + a;
    printString(s); // @output "__"
    printString(a + b); // @output "_x"
    printString(a + c); // @output "_ "
    printString(a + d); // @output "_y"

    printString(b + a); // @output "x_"
    printString(b + b); // @output "xx"
    printString(b + c); // @output "x "
    printString(b + d); // @output "xy"

    printString(c + a); // @output " _"
    printString(c + b); // @output " x"
    printString(c + c); // @output "  "
    printString(c + d); // @output " y"

    printString(d + a); // @output "y_"
    printString(d + b); // @output "yx"
    printString(d + c); // @output "y "
    printString(d + d); // @output "yy"
}

function printString(string s) {
    io:println(s.toBalString());
}

Test-Case: output
Description: Test string concatenation with user-defined subtype of string.
Labels: additive-expr, string, value:toBalString, module-type-defn, union-type

type Chars "a"|"b";
type Strings "c"|"de";

function init() {
    Chars a = "a";
    Chars b = "b";
    Strings c = "c";
    Strings d = "de";

    string s = a + a;
    printString(s); // @output "aa"
    printString(a + b); // @output "ab"
    printString(a + c); // @output "ac"
    printString(a + d); // @output "ade"

    s = b + a;
    printString(s); // @output "ba"
    printString(b + b); // @output "bb"
    printString(b + c); // @output "bc"
    printString(b + d); // @output "bde"

    s = c + a;
    printString(c + a); // @output "ca"
    printString(c + b); // @output "cb"
    printString(c + c); // @output "cc"
    printString(c + d); // @output "cde"

    s = d + a;
    printString(s); // @output "dea"
    printString(d + b); // @output "deb"
    printString(d + c); // @output "dec"
    printString(d + d); // @output "dede"
}

function printString(string s) {
    io:println(s.toBalString());
}

Test-Case: output
Description: Test concatenation of string:Char and user-defined string subtype variable holding a string:Char.
Labels: additive-expr, string, string:Char, value:toBalString, module-type-defn, union-type

type Strings "a"|"bc";

function init() {
    Strings a = "a";
    string:Char b = "b";

    string s = a + b;
    printString(s); // @output "ab"
    printString(b + a); // @output "ba"
}

function printString(string s) {
    io:println(s.toBalString());
}

Test-Case: output
Description: Test concatenation of string:Char and user-defined string subtype variable holding a non-string:Char value.
Fail-Issue: ballerina-platform/ballerina-lang#32813
Labels: additive-expr, string, string:Char, value:toBalString, module-type-defn, union-type

type Strings "a"|"bc";

function init() {
    Strings a = "bc";
    string:Char b = "d";

    string s = a + b;
    printString(s); // @output "bcd"
    printString(b + a); // @output "dbc"
}

function printString(string s) {
    io:println(s.toBalString());
}

Test-Case: output
Description: Test concatenation of string:Char and string.
Fail-Issue: ballerina-platform/ballerina-lang#32814
Labels: additive-expr, string, string:Char, value:toBalString, module-type-defn, union-type

function init() {
    string:Char a = "d";
    string b = "efg";
    string c = "h";

    string s = a + b;
    printString(s); // @output "defg"
    printString(a + c); // @output "dh"

    s = b + a;
    printString(s); // @output "efgd"
    printString(c + a); // @output "hd"
}

function printString(string s) {
    io:println(s.toBalString());
}

Test-Case: output
Description: Test concatenation of string and user-defined string subtype.
Labels: additive-expr, string, string:Char, value:toBalString, module-type-defn, union-type

type Strings "a"|"bc";

function init() {
    Strings a = "a";
    Strings b = "bc";
    string c = "d";
    string d = "ef";

    string s = a + c;
    printString(s); // @output "ad"
    printString(a + d); // @output "aef"

    s = b + c;
    printString(s); // @output "bcd"
    printString(b + d); // @output "bcef"

    s = c + a;
    printString(s); // @output "da"
    printString(c + b); // @output "dbc"

    s = d + a;
    printString(s); // @output "efa"
    printString(d + b); // @output "efbc"
}

function printString(string s) {
    io:println(s.toBalString());
}

Test-Case: output
Description: Test concatenation of string with StringSingleEscape.
Labels: additive-expr, string, StringSingleEscape, value:toBalString

function init() {
    string a = "a\tb";
    string b = "\nc";
    string c = "\\";
    string d = "\"d\"";

    io:println(a + a); // @output a	ba	b
    io:println(a + b); // @output a	b
                       // @output c
    io:println(a + c); // @output a	b\
    io:println(a + d); // @output a	b"d"

    io:println((b + a).toBalString()); // @output "
                                       // @output ca	b"
    io:println((b + b).toBalString()); // @output "
                                       // @output c
                                       // @output c"
    io:println((b + c).toBalString()); // @output "
                                       // @output c\"
    io:println((b + d).toBalString()); // @output "
                                       // @output c"d""

    io:println(c + a); // @output \a	b
    io:println(c + b); // @output \
                       // @output c
    io:println(c + c); // @output \\
    io:println(c + d); // @output \"d"

    io:println(d + a); // @output "d"a	b
    io:println(d + b); // @output "d"
                       // @output c
    io:println(d + c); // @output "d"\
    io:println(d + d); // @output "d""d"
}

Test-Case: output
Description: Test concatenation of string with NumericEscape.
Labels: additive-expr, string, StringNumericEscape, value:toBalString

function init() {
    string a = "a\u{0040}b";
    string b = "\u{1E41}";

    io:println(a + a); // @output a@ba@b
    io:println(a + b); // @output a@bṁ

    io:println(b + a); // @output ṁa@b
    io:println(b + b); // @output ṁṁ
}

Test-Case: output
Description: Test string concatenation with string literal and string template expressions as operands.
Labels: additive-expr, string, BacktickString

function init() {
    string name = "ballerina";
    io:println("hello " + string `world from ${name}`); // @output hello world from ballerina
}

Test-Case: output
Description: Test string concatenation with field access expressions as operands.
Labels: additive-expr, string, field-access-expr, explicit-new-expr, module-class-defn, record-type

function init() {
    Bar b = {name: "test"};
    io:println(b.name + (new Foo()).id); // @output testABC
}

class Foo {
    string id = "ABC";
}

type Bar record {|
    string name;
|};

Test-Case: output
Description: Test string concatenation with function call and method call expressions as operands.
Labels: additive-expr, string, function-call-expr, method-call-expr, implicit-new-expr, explicit-new-expr, module-class-defn

function init() {
    Class cl = new;
    io:println(getString() + cl.getString()); // @output foobar
    io:println(cl.getString() + getString()); // @output barfoo
    io:println(getString() + getString()); // @output foofoo
    io:println(cl.getString() + (new Class()).getString()); // @output barbar
}

function getString() returns string {
    return "foo";
}

class Class {
    function getString() returns string {
        return "bar";
    }
}

Test-Case: output
Description: Test string concatenation with let expressions as operands.
Labels: additive-expr, string, let-expr

function init() {
    string s = (let string a = "hello", string b = "world" in a + " " + b ) + let string a = "!" in a;
    io:println(s); // @output hello world!
}

Test-Case: output
Description: Test string concatenation with type cast expressions as operands.
Labels: additive-expr, string, type-cast-expr, optional-type, string:Char

function init() {
    string s = "!";
    string? t = "hi";
    io:println(<string> t + <string:Char> s); // @output hi!
}

Test-Case: output
Description: Test string concatenation with additive expressions as operands.
Labels: additive-expr, string, module-type-defn, union-type, string:Char

type Chars "H"|"I";

function init() {
    Chars s = "H";
    string:Char t = "e";
    string u = "llo";
    string v = " from ballerina";
    string w = "!";

    string x = (s + t + u) + v + w;
    io:println(x); // @output Hello from ballerina!

    string y = s + t + u + v + w;
    io:println(y); // @output Hello from ballerina!

    string z = (s + t) + u + v + w;
    io:println(z); // @output Hello from ballerina!
}

Test-Case: output
Description: Test string concatenation with conditional expressions as operands.
Labels: additive-expr, string, union-expr, optional-type, error, conditional-expr

function init() {
    string? s = "hello";
    string|error t = " world";
    string u = (s ?: "hi") + (t is error ? "!" : t);
    io:println(u); // @output hello world
}

Test-Case: output
Description: Test string concatenation with checking expressions as operands.
Labels: additive-expr, string, union-expr, optional-type, error, check, checkpanic

function init() returns error? {
    string|error s = "hello";
    string|error t = " world";
    string u = check s + checkpanic t;
    io:println(u); // @output hello world
    io:println(check s + checkpanic t); // @output hello world
}

Test-Case: error
Description: Test invalid concatenation with XML.
Labels: additive-expr, int, xml, nil-type, array-type

function testFunction(xml a, int b, () c, xml[] d) {
    xml _ = a + b; // @error cannot concatenate xml and int
    xml _ = a + c; // @error cannot concatenate xml and nil
    xml _ = a + d; // @error cannot concatenate xml and array
    xml _ = b + a + a; // @error cannot concatenate xml and int
    xml _ = c + a; // @error cannot concatenate xml and nil
    xml _ = d + a; // @error cannot concatenate xml and array
}

Test-Case: error
Description: Test invalid static type of XML concatenation.
Labels: additive-expr, xml, int, string

function testFunction(xml a, xml b) {
    int _ = a + b; // @error static type of xml concatenation is xml
    string _ = a + b + a; // @error static type of xml concatenation is xml
}

Test-Case: error
Description: Test invalid static type of xml concatenation with built-in subtype of xml.
Labels: additive-expr, xml, int, string, xml:Element, xml:Comment, xml:ProcessingInstruction, xml:Text

function testFunction(xml a, xml:Element b, xml:Comment c, xml:ProcessingInstruction d, xml:Text e) {
    int _ = a + b; // @error static type of xml concatenation is xml
    xml:Element _ = a + b; // @error static type of xml concatenation is xml
    xml:Comment _ = a + c; // @error static type of xml concatenation is xml
    xml:ProcessingInstruction _ = a + d; // @error static type of xml concatenation is xml
    xml:Text _ = a + e; // @error static type of xml concatenation is xml
    string _ = a + e; // @error static type of xml concatenation is xml
}

Test-Case: error
Description: Test invalid static type of xml concatenation of operands of built-in subtypes of xml.
Labels: additive-expr, xml, int, string, xml:Element, xml:Comment, xml:ProcessingInstruction, xml:Text, xml-type-param

function testFunction(xml:Element b, xml:Comment c, xml:ProcessingInstruction d, xml:Text e) {
    xml:Element _ = b + b; // @error static type of xml:Element concatenation is xml<xml:Element>
    xml<xml:Element> _ = b + d; // @error static type of xml:Element and xml:ProcessingInstruction concatenation is xml<xml:Element|xml:ProcessingInstruction>
    xml:Comment _ = c + c; // @error static type of xml:Comment concatenation is xml<xml:Comment>
    xml:ProcessingInstruction _ = d + d; // @error static type of xml:ProcessingInstruction concatenation is xml<xml:ProcessingInstruction>
    xml:ProcessingInstruction|xml:Comment _ = d + c; // @error static type of xml:Comment and xml:ProcessingInstruction concatenation is xml<xml:Comment|xml:ProcessingInstruction>
    xml:Element|xml:Text|xml:ProcessingInstruction _ = b + e; // @error static type of xml:Element and xml:Text concatenation is xml<xml:Element|xml:Text>
    string _ = e + e; // @error static type of xml:Text concatenation is xml<xml:Text>
    xml:Comment _ = e + e; // @error static type of xml:Text concatenation is xml<xml:Text>
    xml<xml:Comment> _ = e + e; // @error static type of xml:Text concatenation is xml<xml:Text>
}

Test-Case: error
Description: Test invalid optional xml concatenation.
Labels: additive-expr, xml, optional-type

function testFunction(xml? a, xml? b, xml c) {
    xml _ = a + b; // @error cannot concatenate optional xml
    xml? _ = a + b; // @error cannot concatenate optional xmls
    xml _ = a + c; // @error cannot concatenate xml and optional xml
    xml _ = c + a + c; // @error cannot concatenate xml and optional xml
}

Test-Case: error
Description: Test invalid optional xml subtype concatenation.
Labels: additive-expr, xml, xml:Element, xml:Comment, xml:ProcessingInstruction, xml:Text, optional-type, union-type

function testFunction(xml? a, xml:Element? b, xml:Comment? c, xml:ProcessingInstruction? d, xml:Text? e) {
    xml _ = a + b; // @error cannot concatenate optional xml
    xml:Element? _ = a + b; // @error cannot concatenate optional xml
    xml? _ = a + b; // @error cannot concatenate optional xml
    xml? _ = b + c; // @error cannot concatenate optional xml
    xml? _ = a + a + c + c; // @error cannot concatenate optional xml
    xml:ProcessingInstruction|xml:Text? _ = d + c; // @error cannot concatenate optional xml
}

Test-Case: error
Description: Test xml concatenation static type via invalid assignment with var.
Labels: additive-expr, xml, xml:Element, xml:Comment, xml:ProcessingInstruction, xml:Text, xml-type-param, var

function testFunction(xml a, xml:Element b, xml:Comment c, xml:ProcessingInstruction d, xml:Text e) {
    var f = a + a;
    xml<xml:Element> v1 = f; // @error incompatible types: expected xml<xml:Element> found xml
    xml:Element v2 = f; // @error incompatible types: expected xml:Element found xml

    var g = a + b;
    v1 = g; // @error incompatible types: expected xml<xml:Element> found xml
    v2 = g; // @error incompatible types: expected xml:Element found xml

    var h = a + c;
    v1 = h; // @error incompatible types: expected xml<xml:Element> found xml
    v2 = h; // @error incompatible types: expected xml:Element found xml

    var o = b + d + e;
    v1 = o; // @error incompatible types: expected xml<xml:Element> found xml<xml:Element|xml:ProcessingInstruction|xml:Text>
    v2 = o; // @error incompatible types: expected xml:Element found xml<xml:Element|xml:ProcessingInstruction|xml:Text>

    var i = b + a;
    v1 = i; // @error incompatible types: expected xml<xml:Element> found xml
    v2 = i; // @error incompatible types: expected xml:Element found xml

    var j = b + b;
    xml<xml:Comment|xml:ProcessingInstruction> v3 = j; // @error incompatible types: expected xml<xml:Comment|xml:ProcessingInstruction> found xml<xml:Element>
    v2 = j; // @error incompatible types: expected xml:Element found xml<xml:Element>

    var k = b + c;
    v1 = k; // @error incompatible types: expected xml<xml:Element> found xml<xml:Element|xml:Comment>
    v2 = k; // @error incompatible types: expected xml:Element found xml<xml:Element|xml:Comment>

    var l = c + a;
    v1 = l; // @error incompatible types: expected xml<xml:Element> found xml
    v2 = l; // @error incompatible types: expected xml:Element found xml

    var m = c + b;
    v1 = m; // @error incompatible types: expected xml<xml:Element> found xml<xml:Element|xml:Comment>
    v2 = m; // @error incompatible types: expected xml:Element found xml<xml:Element|xml:Comment>

    var n = c + c;
    v1 = n; // @error incompatible types: expected xml<xml:Element> found xml<xml:Comment>
    v2 = n; // @error incompatible types: expected xml:Element found xml<xml:Comment>

    var p = d + d;
    v1 = p; // @error incompatible types: expected xml<xml:Element> found xml<xml:ProcessingInstruction>
    v2 = p; // @error incompatible types: expected xml:Element found xml<xml:ProcessingInstruction>

    var q = e + e;
    v1 = q; // @error incompatible types: expected xml<xml:Element> found xml<xml:Text>
    v2 = q; // @error incompatible types: expected xml:Element found xml<xml:Text>
}

Test-Case: output
Description: Test xml concatenation.
Labels: additive-expr, xml

function init() {
    xml a = xml `foo`;
    xml b = xml `<!--bar-->`;
    xml c = xml `<baz/>`;
    xml d = xml `<?qux?>`;

    xml e = a + a;
    io:println(e); // @output foofoo
    io:println(a + b); // @output foo<!--bar-->
    io:println(a + c); // @output foo<baz></baz>
    io:println(a + d); // @output foo<?qux ?>

    e = b + a;
    io:println(e); // @output <!--bar-->foo
    io:println(b + b); // @output <!--bar--><!--bar-->
    io:println(b + c); // @output <!--bar--><baz></baz>
    io:println(b + d); // @output <!--bar--><?qux ?>

    e = c + a;
    io:println(e); // @output <baz></baz>foo
    io:println(c + b); // @output <baz></baz><!--bar-->
    io:println(c + c); // @output <baz></baz><baz></baz>
    io:println(c + d); // @output <baz></baz><?qux ?>

    e = d + a;
    io:println(e); // @output <?qux ?>foo
    io:println(d + b); // @output <?qux ?><!--bar-->
    io:println(d + c); // @output <?qux ?><baz></baz>
    io:println(d + d); // @output <?qux ?><?qux ?>
}

Test-Case: output
Description: Test xml concatenation with sequences.
Labels: additive-expr, xml, xml-type-param, xml:Element, xml:Comment, xml:ProcessingInstruction, xml:Text

function init() {
    xml a = xml `foo`;
    xml b = xml `bar<!--bar-->`;
    xml<xml:Element|xml:ProcessingInstruction> c = xml `<baz/><?qux?>`;

    xml e = a + a;
    io:println(e); // @output foofoo
    io:println(a + b); // @output foobar<!--bar-->
    io:println(a + c); // @output foo<baz></baz><?qux ?>

    e = b + a;
    io:println(e); // @output bar<!--bar-->foo
    io:println(b + b); // @output bar<!--bar-->bar<!--bar-->
    io:println(b + c); // @output bar<!--bar--><baz></baz><?qux ?>

    e = c + a;
    io:println(e); // @output <baz></baz><?qux ?>foo
    io:println(c + b); // @output <baz></baz><?qux ?>bar<!--bar-->
    io:println(c + c); // @output <baz></baz><?qux ?><baz></baz><?qux ?>

    xml<xml:Element|xml:ProcessingInstruction> f = c + c;
    io:println(f); // @output <baz></baz><?qux ?><baz></baz><?qux ?>

    e = a + b + c;
    io:println(e); // @output foobar<!--bar--><baz></baz><?qux ?>
    io:println(c + e); // @output <baz></baz><?qux ?>foobar<!--bar--><baz></baz><?qux ?>
}

Test-Case: output
Description: Test xml concatenation with different subtypes of xml.
Labels: additive-expr, xml, xml-type-param, xml:Element, xml:Comment, xml:ProcessingInstruction, xml:Text, never, is-expr, value:toBalString

function init() {
    xml:Text a = xml `foo`;
    xml:Comment b = xml `<!--bar-->`;
    xml:Element c = xml `<baz>baz value</baz>`;
    xml:ProcessingInstruction d = xml `<?qux val?>`;
    xml<xml:Text|xml:Comment> e = xml ` <!--c1--> <!--c2--> `;

    xml<xml:Text> f = a + a;
    io:println(f); // @output foofoo
    io:println(f is xml:Text); // @output true
    io:println(f is xml<never>); // @output false

    xml:Text g = a + a;
    io:println(g); // @output foofoo
    io:println(g is xml:Text); // @output true

    xml<xml:Text|xml:Comment> h = a + b;
    io:println(h); // @output foo<!--bar-->
    io:println(h is xml<xml:Text|xml:Comment>); // @output true
    io:println(h is xml<xml:Text>); // @output false

    xml<xml:Text|xml:Element> i = a + c;
    io:println(i); // @output foo<baz>baz value</baz>
    io:println(i is xml<xml:Text|xml:Element>); // @output true
    io:println(i is xml<xml:Element>); // @output false

    xml<xml:ProcessingInstruction|xml:Element|xml:Text> j = a + d;
    io:println(j); // @output foo<?qux val?>
    io:println(j is xml<xml:Text|xml:ProcessingInstruction>); // @output true
    io:println(j is xml<xml:Element|xml:ProcessingInstruction>); // @output false

    xml<xml:Comment|xml:Text> k = a + e;
    io:println(k.toBalString()); // @output xml`foo <!--c1--> <!--c2--> `
    io:println(k is xml<xml:Text|xml:Comment>); // @output true
    io:println(k is xml<xml:Text>); // @output false

    xml<xml:Comment|xml:Text> l = b + a;
    io:println(l); // @output <!--bar-->foo
    io:println(l is xml<xml:Comment|xml:Text>); // @output true
    io:println(l is xml<xml:Text>); // @output false

    xml<xml:Comment> m = b + b;
    io:println(m); // @output <!--bar--><!--bar-->
    io:println(m is xml<xml:Comment>); // @output true

    xml<xml:Comment|xml:Element> n = b + c;
    io:println(n); // @output <!--bar--><baz>baz value</baz>
    io:println(n is xml<xml:Comment|xml:Element>); // @output true
    io:println(n is xml<xml:Comment>); // @output false

    xml<xml:ProcessingInstruction|xml:Comment> o = b + d;
    io:println(o); // @output <!--bar--><?qux val?>
    io:println(o is xml<xml:Comment|xml:ProcessingInstruction>); // @output true
    io:println(o is xml<xml:Comment>); // @output false

    xml<xml:Text|xml:Comment> p = b + e;
    io:println(p.toBalString()); // @output xml`<!--bar--> <!--c1--> <!--c2--> `
    io:println(p is xml<xml:Comment|xml:Text>); // @output true
    io:println(p is xml<xml:Comment>); // @output false

    xml<xml:Text|xml:Element> q = c + a;
    io:println(q); // @output <baz>baz value</baz>foo
    io:println(q is xml<xml:Text|xml:Element>); // @output true
    io:println(q is xml<never>); // @output false
    io:println(q is xml<xml:Text>); // @output false

    xml<xml:Element|xml:Comment> r = c + b;
    io:println(r); // @output <baz>baz value</baz><!--bar-->
    io:println(r is xml<xml:Element|xml:Comment>); // @output true
    io:println(r is xml<xml:Element>); // @output false

    xml<xml:Element> s = c + c;
    io:println(s); // @output <baz>baz value</baz><baz>baz value</baz>
    io:println(s is xml<xml:Text|xml:Element>); // @output true
    io:println(s is xml<xml:Element>); // @output true

    xml<xml:ProcessingInstruction|xml:Element> t = c + d;
    io:println(t); // @output <baz>baz value</baz><?qux val?>
    io:println(t is xml<xml:Element|xml:ProcessingInstruction>); // @output true
    io:println(t is xml<xml:Element>); // @output false

    xml<xml:Comment|xml:Text|xml:Element> u = c + e;
    io:println(u.toBalString()); // @output xml`<baz>baz value</baz> <!--c1--> <!--c2--> `
    io:println(u is xml<xml:Text|xml:Comment|xml:Element>); // @output true
    io:println(u is xml<xml:Comment|xml:Element>); // @output false

    xml<xml:ProcessingInstruction> v = d + d;
    io:println(v); // @output <?qux val?><?qux val?>
    io:println(v is xml<xml:ProcessingInstruction>); // @output true
    io:println(v is xml<never>); // @output false

    xml<xml:ProcessingInstruction|xml:Text|xml:Comment> w = d + e;
    io:println(w.toBalString()); // @output xml`<?qux val?> <!--c1--> <!--c2--> `
    io:println(w is xml<xml:ProcessingInstruction|xml:Text|xml:Comment>); // @output true
    io:println(w is xml<never>); // @output false
    io:println(w is xml<xml:Text|xml:Comment>); // @output false

    xml<xml:Text|xml:Comment> x = e + e;
    io:println(x.toBalString()); // @output xml` <!--c1--> <!--c2-->  <!--c1--> <!--c2--> `
    io:println(x is xml<xml:Text|xml:Comment>); // @output true
    io:println(x is xml<never>); // @output false
}

Test-Case: output
Description: Test xml concatenation with empty xml sequence.
Labels: additive-expr, xml, xml-type-param, xml:Element, xml:Comment, xml:ProcessingInstruction, xml:Text, never, value:toBalString

function init() {
    xml:Text a = xml `foo`;
    xml:Comment b = xml `<!--bar-->`;
    xml:Element c = xml `<baz>baz value</baz>`;
    xml:ProcessingInstruction d = xml `<?qux val?>`;
    xml<xml:Text|xml:Comment> e = xml ` <!--c1--> <!--c2--> `;
    xml f = xml ``;
    xml<never> g = xml ``;

    xml h = a + f;
    io:println(h); // @output foo
    io:println(h is xml:Text); // @output true
    io:println(h is xml<xml:Text>); // @output true
    io:println(h is xml<never>); // @output false

    xml i = g + a;
    io:println(i); // @output foo
    io:println(i is xml:Text); // @output true
    io:println(i is xml<xml:Text>); // @output true
    io:println(i is xml<never>); // @output false

    xml j = b + f;
    io:println(j); // @output <!--bar-->
    io:println(j is xml:Comment); // @output true
    io:println(j is xml<xml:Comment>); // @output true
    io:println(j is xml<never>); // @output false

    xml k = g + b;
    io:println(k); // @output <!--bar-->
    io:println(k is xml:Comment); // @output true
    io:println(k is xml<xml:Comment>); // @output true
    io:println(k is xml<never>); // @output false

    xml l = c + f;
    io:println(l); // @output <baz>baz value</baz>
    io:println(l is xml:Element); // @output true
    io:println(l is xml<xml:Element>); // @output true
    io:println(l is xml<never>); // @output false

    xml m = g + c;
    io:println(m); // @output <baz>baz value</baz>
    io:println(m is xml:Element); // @output true
    io:println(m is xml<xml:Element>); // @output true
    io:println(m is xml<never>); // @output false

    xml n = d + f;
    io:println(n); // @output <?qux val?>
    io:println(n is xml:ProcessingInstruction); // @output true
    io:println(n is xml<xml:ProcessingInstruction>); // @output true
    io:println(n is xml<never>); // @output false

    xml o = g + d;
    io:println(o); // @output <?qux val?>
    io:println(o is xml:ProcessingInstruction); // @output true
    io:println(o is xml<xml:ProcessingInstruction>); // @output true
    io:println(o is xml<never>); // @output false

    xml p = e + f;
    io:println(p.toBalString()); // @output xml` <!--c1--> <!--c2--> `
    io:println(p is xml<xml:Text|xml:Comment>); // @output true
    io:println(p is xml:Text|xml:Comment); // @output false
    io:println(p is xml<never>); // @output false

    xml q = g + e;
    io:println(q.toBalString()); // @output xml` <!--c1--> <!--c2--> `
    io:println(q is xml<xml:Text|xml:Comment>); // @output true
    io:println(q is xml:Text|xml:Comment); // @output false
    io:println(q is xml<never>); // @output false
}

Test-Case: output
Description: Test new sequence creation on xml concatenation.
Labels: additive-expr, xml, xml-type-param, xml:Element, xml:Comment, xml:ProcessingInstruction, xml:Text, never

function init() {
    xml:Text a = xml `foo`;
    xml:Comment b = xml `<!--bar-->`;
    xml:Element c = xml `<baz>baz value</baz>`;
    xml:ProcessingInstruction d = xml `<?qux val?>`;
    xml<xml:Text|xml:Comment> e = xml ` <!--c1--> <!--c2--> `;
    xml f = xml `<a/><b>bcd</b>`;
    xml g = xml ``;

    xml h = a + b;
    io:println(a === h); // @output false
    io:println(h === a); // @output false

    h = f + a;
    io:println(a === h); // @output false
    io:println(h === f); // @output false

    h = b + c;
    io:println(c === h); // @output false
    io:println(h === b); // @output false

    h = f + b;
    io:println(b === h); // @output false
    io:println(h === f); // @output false

    h = c + d;
    io:println(d === h); // @output false
    io:println(h === c); // @output false

    h = f + c;
    io:println(c === h); // @output false
    io:println(h === f); // @output false

    h = d + a;
    io:println(d === h); // @output false
    io:println(h === a); // @output false

    h = f + d;
    io:println(d === h); // @output false
    io:println(h === f); // @output false

    h = e + e;
    io:println(e === h); // @output false
    io:println(h === e); // @output false

    h = f + e;
    io:println(e === h); // @output false
    io:println(h === f); // @output false

    h = f + a;
    io:println(f === h); // @output false
    io:println(h === a); // @output false

    h = f + f;
    io:println(f === h); // @output false
    io:println(h === f); // @output false

    h = b + g;
    io:println(b === h); // @output false
    io:println(h === g); // @output false

    h = g + c;
    io:println(c === h); // @output false
    io:println(h === g); // @output false

    h = g + d;
    io:println(d === h); // @output false
    io:println(h === g); // @output false

    h = e + g;
    // true due to sequence check
    io:println(e === h); // @output true

    io:println(h === g); // @output false

    h = g + f;
    // true due to sequence check
    io:println(f === h); // @output true

    io:println(h === g); // @output false
}

Test-Case: output
Description: Test xml concatenation not performing a copy on the constituents of the operand values.
Labels: additive-expr, xml, xml-type-param, xml:Element, xml:Comment, xml:ProcessingInstruction, xml:Text, xml:get

function init() {
    xml:Text a = xml `foo`;
    xml:Element b = xml `<bar>bar val</bar>`;
    xml:Comment c = xml `<!--baz-->`;
    xml:ProcessingInstruction d = xml `<?qux val?>`;
    xml e = xml `<elem/> text <!--comment-->`;
    xml<xml:Element|xml:ProcessingInstruction> f = xml `<e2/><?p2 val2?>`;

    xml g = a + b;
    io:println(g); // @output foo<bar>bar val</bar>
    io:println((g.<bar>).get(0) === b); // @output true

    g = b + a;
    io:println(g); // @output <bar>bar val</bar>foo
    io:println((g.<bar>).get(0) === b); // @output true

    g = c + b;
    io:println(g); // @output <!--baz--><bar>bar val</bar>
    io:println(g.get(0) === c); // @output true
    io:println(g.get(1) === b); // @output true

    g = a + b + c + d;
    io:println(g); // @output foo<bar>bar val</bar><!--baz--><?qux val?>
    io:println(g.get(1) === b); // @output true
    io:println(g.get(2) === c); // @output true
    io:println(g.get(3) === d); // @output true

    g = d + e;
    io:println(g); // @output <?qux val?><elem></elem> text <!--comment-->
    io:println(g.get(0) === d); // @output true
    io:println(g.get(1) === e.get(0)); // @output true
    io:println(g.get(3) === e.get(2)); // @output true

    g = e + f;
    io:println(g); // @output <elem></elem> text <!--comment--><e2></e2><?p2 val2?>
    io:println(g.get(0) === e.get(0)); // @output true
    io:println(g.get(2) === e.get(2)); // @output true
    io:println(g.get(3) === f.get(0)); // @output true
    io:println(g.get(4) === f.get(1)); // @output true
}

Test-Case: output
Description: Test xml concatenation with xml literal expressions as operands.
Labels: additive-expr, xml, int

function init() {
    int id = 21;
    io:println(xml `hello` + xml `<count>${id}</count>`); // @output hello<count>21</count>
}

Test-Case: output
Description: Test xml concatenation with field access expressions as operands.
Labels: additive-expr, xml, field-access-expr, explicit-new-expr, module-class-defn, record-type

function init() {
    Bar b = {comment: xml `<!--this is a comment-->`};
    io:println(b.comment + (new Foo()).id); // @output <!--this is a comment--><id>1234</id><default></default>
}

class Foo {
    xml id = xml `<id>1234</id><default/>`;
}

type Bar record {|
    xml:Comment comment;
|};

Test-Case: output
Description: Test xml concatenation with function call and method call expressions as operands.
Labels: additive-expr, xml, function-call-expr, method-call-expr, implicit-new-expr, explicit-new-expr, module-class-defn

function init() {
    Class cl = new;
    io:println(getXml() + cl.getXml()); // @output <foo>1234</foo><!--Comment 1--> <!--Comment 2-->
    io:println(cl.getXml() + getXml()); // @output <!--Comment 1--> <!--Comment 2--><foo>1234</foo>
    io:println(getXml() + getXml()); // @output <foo>1234</foo><foo>1234</foo>
    io:println(cl.getXml() + (new Class()).getXml()); // @output <!--Comment 1--> <!--Comment 2--><!--Comment 1--> <!--Comment 2-->
}

function getXml() returns xml:Element {
    return xml `<foo>1234</foo>`;
}

class Class {
    function getXml() returns xml<xml:Comment|xml:Text> {
        return xml `<!--Comment 1--> <!--Comment 2-->`;
    }
}

Test-Case: output
Description: Test xml concatenation with let expressions as operands.
Labels: additive-expr, xml, let-expr, xml:Element

function init() {
    xml s = (let xml a = xml `abc`, xml:Element b = xml `<def/>` in a + xml ` ` + b ) + let xml a = xml `<a> a val </a><!--b-->` in a;
    io:println(s); // @output abc <def></def><a> a val </a><!--b-->
}

Test-Case: output
Description: Test xml concatenation with type cast expressions as operands.
Labels: additive-expr, xml, type-cast-expr, optional-type, xml:Element

function init() {
    xml s = xml `<elem/>`;
    xml? t = xml `foo`;
    io:println(<xml> t + <xml:Element> s); // @output foo<elem></elem>
}

Test-Case: output
Description: Test xml concatenation with additive expressions as operands.
Labels: additive-expr, xml, xml:Element, xml:Comment, xml:ProcessingInstruction, xml:Text

function init() {
    xml:Element s = xml `<elem>1234</elem>`;
    xml:Text t = xml `Hello World`;
    xml:ProcessingInstruction u = xml `<?pi 1?>`;
    xml:Comment v = xml `<!--comment 1-->`;
    xml w = xml `<foo></foo>1234<bar>1234</bar>`;

    xml x = (s + t + u) + v + w;
    io:println(x); // @output <elem>1234</elem>Hello World<?pi 1?><!--comment 1--><foo></foo>1234<bar>1234</bar>

    xml y = s + t + u + v + w;
    io:println(y); // @output <elem>1234</elem>Hello World<?pi 1?><!--comment 1--><foo></foo>1234<bar>1234</bar>

    xml z = (s + t) + u + v + w;
    io:println(z); // @output <elem>1234</elem>Hello World<?pi 1?><!--comment 1--><foo></foo>1234<bar>1234</bar>
}

Test-Case: output
Description: Test xml concatenation with conditional expressions as operands.
Fail-Issue: ballerina-platform/ballerina-lang#32959
Labels: additive-expr, xml, union-expr, optional-type, error, conditional-expr

function init() {
    xml? s = xml `foo`;
    xml|error t = xml `<bar/>`;
    xml u = (s ?: xml `<baz/>`) + (t is error ? xml `text` : t);
    io:println(u); // @output foo<bar></bar>
}

Test-Case: output
Description: Test xml concatenation with checking expressions as operands.
Labels: additive-expr, xml, union-expr, optional-type, error, check, checkpanic

function init() returns error? {
    xml r = xml `world<done/>`;
    xml|error s = xml `hello`;
    xml|error t = r;

    xml u = check s + checkpanic t;
    io:println(u); // @output helloworld<done></done>
    io:println(check t + checkpanic s); // @output world<done></done>hello
}

Test-Case: error
Description: Test invalid static type of string and XML concatenation.
Labels: additive-expr, xml, string, xml:Element

function testFunction(xml a, string b) {
    string _ = a + b; // @error static type of string and xml concatenation is xml
    string _ = a + b + a; // @error static type of string and xml concatenation is xml
    xml:Element _ = a + b; // @error static type of string and xml concatenation is xml
}

Test-Case: error
Description: Test invalid static type of string built-in subtype and xml concatenation.
Labels: additive-expr, xml, string, string:Char

function testFunction(xml a, string f, string:Char g) {
    string _ = a + f; // @error static type of string and xml concatenation is xml
    string _ = g + a; // @error static type of string and xml concatenation is xml
    string _ = g + a + f; // @error static type of string and xml concatenation is xml
}

Test-Case: error
Description: Test invalid static type of user-defined string subtype and xml concatenation.
Labels: additive-expr, xml, string, module-type-defn, union-type, string-literal

type Strings "foo";
type Chars "a"|"b";

function testFunction(xml a, Strings f, Chars g) {
    string _ = a + f; // @error static type of string and xml concatenation is xml
    string _ = g + a; // @error static type of string and xml concatenation is xml
    string _ = g + a + f; // @error static type of string and xml concatenation is xml
}

Test-Case: error
Description: Test invalid static type of string built-in subtype and xml:Text concatenation.
Labels: additive-expr, string, xml:Text, string:Char

function testFunction(xml:Text e, string f, string:Char g) {
    string _ = e + f; // @error static type of string and xml concatenation is xml:Text
    string _ = g + e; // @error static type of string and xml concatenation is xml:Text
    string _ = g + e + g + f; // @error static type of string and xml concatenation is xml:Text
}

Test-Case: error
Description: Test invalid static type of user-defined string subtype and xml:Text concatenation.
Labels: additive-expr, xml:Text. module-type-defn, union-type, string-literal

type Strings "foo";
type Chars "a"|"b";

function testFunction(xml:Text e, Strings f, Chars g) {
    string _ = e + f; // @error static type of string and xml concatenation is xml:Text
    string _ = g + e; // @error static type of string and xml concatenation is xml:Text
    string _ = g + e + g + f; // @error static type of string and xml concatenation is xml:Text
}

Test-Case: error
Description: Test invalid static type of string built-in subtype and xml built-in subtype concatenation.
Fail-Issue: ballerina-platform/ballerina-lang#32975
Labels: additive-expr, xml, int, xml:Element, xml:Comment, xml:ProcessingInstruction, string:Char

function testFunction(xml:Element b, xml:Comment c, xml:ProcessingInstruction d, string f, string:Char g) {
    xml:Element _ = b + f; // @error static type of string and xml concatenation is xml
    string _ = g + b; // @error static type of string and xml concatenation is xml
    string _ = g + b + g; // @error static type of string and xml concatenation is xml
    xml:Comment _ = c + f; // @error static type of string and xml concatenation is xml
    string _ = c + (g + c); // @error static type of string and xml concatenation is xml
    int _ = d + f; // @error static type of string and xml concatenation is xml
    xml:ProcessingInstruction _ = g + d; // @error static type of string and xml concatenation is xml
}

Test-Case: error
Description: Test invalid static type of user-defined string subtype and xml subtype concatenation.
Fail-Issue: ballerina-platform/ballerina-lang#32975
Labels: additive-expr, xml, xml:Element, xml:Comment, xml:ProcessingInstruction, module-type-defn, union-type, string-literal

type Strings "foo";
type Chars "a"|"b";

function testFunction(xml:Element b, xml:Comment c, xml:ProcessingInstruction d, Strings f, Chars g) {
    xml:Element _ = b + f; // @error static type of string and xml concatenation is xml
    string _ = g + b; // @error static type of string and xml concatenation is xml
    string _ = g + b + g; // @error static type of string and xml concatenation is xml
    xml:Comment _ = c + f; // @error static type of string and xml concatenation is xml
    string _ = c + (g + c); // @error static type of string and xml concatenation is xml
    string _ = d + f; // @error static type of string and xml concatenation is xml
    xml:ProcessingInstruction _ = g + d; // @error static type of string and xml concatenation is xml
}

Test-Case: error
Description: Test invalid optional xml and string concatenation.
Labels: additive-expr, xml, optional-type

function testFunction(xml? a, string? b, string c) {
    xml _ = a + b; // @error cannot concatenate optional xml and optional string
    xml? _ = a + b; // @error cannot concatenate optional xml and optional string
    xml _ = a + c; // @error cannot concatenate optional xml and string
    xml _ = c + a + c; // @error cannot concatenate optional xml and optional string
    string? _ = c + a + c; // @error cannot concatenate optional xml, optional string, and string
}

Test-Case: error
Description: Test invalid optional xml and string subtype concatenation.
Labels: additive-expr, xml, xml:Element, xml:Comment, xml:ProcessingInstruction, xml:Text, string:Char, optional-type, union-type

function testFunction(xml? a, xml:Element? b, xml:Comment? c, xml:ProcessingInstruction? d, xml:Text? e, string? f, string:Char? g) {
    xml _ = a + f; // @error cannot concatenate optional xml and string
    xml? _ = a + g; // @error cannot concatenate optional xml and string
    xml? _ = g + b; // @error cannot concatenate optional xml and string
    xml? _ = f + c; // @error cannot concatenate optional xml and string
    string? _ = d + f + g + e; // @error cannot concatenate optional xml and string
    xml:ProcessingInstruction|xml:Text? _ = f + d + e + f; // @error cannot concatenate optional xml and string
}

Test-Case: error
Description: Test xml and string concatenation static type via invalid assignment with var.
Fail-Issue: ballerina-platform/ballerina-lang#32975
Labels: additive-expr, xml, xml:Element, xml:Comment, xml:ProcessingInstruction, xml:Text, var, module-type-defn, string-literal

type Foo "foo";

function testFunction(xml a, xml:Element b, xml:Comment c, xml:ProcessingInstruction d, xml:Text e, string f, string:Char g, Foo h) {
    var i = a + f;
    string _ = i; // @error incompatible types: expected string found xml

    var j = b + g;
    string _ = j; // @error incompatible types: expected string found xml

    var k = h + c;
    Foo _ = k; // @error incompatible types: expected Foo found xml

    var l = d + g;
    xml:ProcessingInstruction _ = l; // @error incompatible types: expected xml:ProcessingInstruction found xml

    var m = e + f + g;
    string _ = m; // @error incompatible types: expected string found xml
}

Test-Case: error
Description: Test xml and string concatenation static type via invalid assignment with var.
Fail-Issue: ballerina-platform/ballerina-lang#32976
Labels: additive-expr, xml, xml:Element, xml:Comment, xml-type-param, union-type, var, module-type-defn, string-literal

type Foo "foo";

function testFunction(Foo a, xml<xml:Element|xml:Comment> b) {
    var n = a + b;
    xml<xml:Element|xml:Comment> _ = n; // @error incompatible types: expected xml<xml:Element|xml:Comment> found xml
}

Test-Case: error
Description: Test static type of empty xml and string concatentation via invalid assignment with var.
Fail-Issue: ballerina-platform/ballerina-lang#32984, ballerina-platform/ballerina-lang#32976
Labels: additive-expr, xml, xml-type-param, never, string, module-type-defn, union-type, string:Char, var

type Foo "foo"|"bar";

function testFunction() {
    string a = "";
    string:Char b = "b";
    Foo c = "foo";
    xml<never> d = xml ``;

    var e = a + d;
    string _ = e; // @error static type of string and empty xml concatenation is xml:Text

    var f = b + d;
    string _ = f; // @error static type of string and empty xml concatenation is xml:Text

    var g = c + d;
    string _ = g; // @error static type of string and empty xml concatenation is xml:Text
}

Test-Case: output
Description: Test xml concatenation for singleton value and empty string.
Labels: additive-expr, xml, string

function init() {
    xml a = xml `foo`;
    xml b = xml `<!--bar-->`;
    xml c = xml `<baz/>`;
    xml d = xml `<?qux?>`;
    string e = "";

    xml f = a + e;
    io:println(f); // @output foo
    io:println(e + a); // @output foo

    f = e + b;
    io:println(f); // @output <!--bar-->
    io:println(b + e); // @output <!--bar-->

    f = c + e;
    io:println(f); // @output <baz></baz>
    io:println(e + c + e); // @output <baz></baz>

    f = d + e;
    io:println(f); // @output <?qux ?>
    io:println(e + d); // @output <?qux ?>
}

Test-Case: output
Description: Test xml concatenation for singleton value and empty string returning the xml value.
Fail-Issue: ballerina-platform/ballerina-lang#32978
Labels: additive-expr, xml, string, any, xml:get

function init() {
    xml a = xml `foo`;
    xml b = xml `<!--bar-->`;
    xml c = xml `<baz/>`;
    xml d = xml `<?qux?>`;
    string e = "";
    any f = e;

    xml g = a + e;
    io:println(g === a); // @output true
    io:println(g.get(0) === a); // @output true
    io:println(g === f); // @output false

    g = e + b;
    io:println(g === b); // @output true
    io:println(g.get(0) === b); // @output true
    io:println(g === f); // @output false

    g = c + e;
    io:println(g === c); // @output true
    io:println(g.get(0) === c); // @output true
    io:println(g === f); // @output false

    g = d + e;
    io:println(g === d); // @output true
    io:println(g.get(0) === d); // @output true
    io:println(g === f); // @output false
}

Test-Case: output
Description: Test xml and empty string concatenation with sequences.
Labels: additive-expr, xml, xml-type-param, xml:Element, xml:Comment, xml:ProcessingInstruction, xml:Text, string

function init() {
    xml a = xml `foo`;
    xml b = xml `bar<!--bar-->`;
    xml<xml:Element|xml:ProcessingInstruction> c = xml `<baz/><?qux?>`;
    string d = "";

    xml e = b + d;
    io:println(e); // @output bar<!--bar-->

    e = c + d;
    io:println(e); // @output <baz></baz><?qux ?>

    e = c + d + c;
    io:println(e); // @output <baz></baz><?qux ?><baz></baz><?qux ?>

    e = a + d + b + d;
    io:println(e); // @output foobar<!--bar-->

    e = a + d + b + d + c;
    io:println(e); // @output foobar<!--bar--><baz></baz><?qux ?>
}

Test-Case: output
Description: Test xml concatenation with different subtypes of xml and string with empty string as the string value.
Fail-Issue: ballerina-platform/ballerina-lang#32975
Labels: additive-expr, xml, string, xml-type-param, xml:Element, xml:Comment, xml:ProcessingInstruction, xml:Text, never, module-type-defn, union-type, is-expr

type Foo "foo"|"";

function init() {
    xml:Text a = xml `foo`;
    xml:Comment b = xml `<!--bar-->`;
    xml:Element c = xml `<baz>baz value</baz>`;
    xml:ProcessingInstruction d = xml `<?qux val?>`;
    xml<xml:Text|xml:Comment> e = xml `<!--c1--> <!--c2-->`;
    string f = "";
    Foo g = "";

    xml:Text h = a + f;
    io:println(h); // @output foo
    io:println(h is xml:Text); // @output true

    h = a + g;
    io:println(h); // @output foo
    io:println(h is xml:Text); // @output true

    xml i = b + f;
    io:println(i); // @output <!--bar-->
    io:println(i is xml:Text); // @output false
    io:println(i is xml:Comment); // @output true

    i = b + g;
    io:println(i); // @output <!--bar-->
    io:println(i is xml:Text); // @output false
    io:println(i is xml:Comment); // @output true

    i = c + f;
    io:println(i); // @output <baz>baz value</baz>
    io:println(i is xml:Text); // @output false
    io:println(i is xml:Element); // @output true

    i = c + g;
    io:println(i); // @output <baz>baz value</baz>
    io:println(i is xml:Text); // @output false
    io:println(i is xml:Element); // @output true

    i = d + f;
    io:println(i); // @output <?qux val?>
    io:println(i is xml:Text); // @output false
    io:println(i is xml:ProcessingInstruction); // @output true

    i = g + d;
    io:println(i); // @output <?qux val?>
    io:println(i is xml:Text); // @output false
    io:println(i is xml:ProcessingInstruction); // @output true

    i = e + f;
    io:println(i); // @output <!--c1--> <!--c2-->
    io:println(i is xml:Text); // @output false
    io:println(i is xml<xml:Comment|xml:Text>); // @output true

    i = g + e;
    io:println(i); // @output <!--c1--> <!--c2-->
    io:println(i is xml:Text); // @output false
    io:println(i is xml<xml:Comment|xml:Text>); // @output true
}

Test-Case: output
Description: Test concatenation of empty xml sequence and empty string.
Labels: additive-expr, xml, xml-type-param, never, value:toBalString, string, module-type-defn, union-type, is-expr

type Foo ""|"foo";

function init() {
    string a = "";
    Foo b = "";
    xml c = xml ``;
    xml<never> d = xml ``;

    xml e = a + c;
    io:println(e.toBalString()); // @output xml``
    io:println(e is xml:Text); // @output true
    io:println(e is xml<never>); // @output true

    e = a + d;
    io:println(e.toBalString()); // @output xml``
    io:println(e is xml:Text); // @output true
    io:println(e is xml<never>); // @output true

    e = c + b;
    io:println(e.toBalString()); // @output xml``
    io:println(e is xml:Text); // @output true
    io:println(e is xml<never>); // @output true

    e = d + b;
    io:println(e.toBalString()); // @output xml``
    io:println(e is xml:Text); // @output true
    io:println(e is xml<never>); // @output true
}

Test-Case: output
Description: Test value of empty xml and string concatentation using the exact static type.
Labels: additive-expr, xml, xml-type-param, never, value:toBalString, string, module-type-defn, union-type, is-expr, string:Char

type Foo "foo"|"bar";

function init() {
    string a = "";
    string:Char b = "b";
    Foo c = "foo";
    xml:Text d = xml ``;
    xml<never> e = xml ``;
    xml f = xml ``;

    xml:Text g = a + d;
    io:println(e.toBalString()); // @output xml``
    io:println(e is xml<never>); // @output true

    xml i = a + f;
    io:println(i.toBalString()); // @output xml``
    io:println(i is xml<never>); // @output true

    xml:Text j = b + d;
    io:println(j.toBalString()); // @output xml`b`
    io:println(j is xml<never>); // @output false

    xml l = b + f;
    io:println(l.toBalString()); // @output xml`b`
    io:println(l is xml<never>); // @output false

    xml:Text m = c + d;
    io:println(m.toBalString()); // @output xml`foo`
    io:println(m is xml<never>); // @output false

    xml:Text n = c + e;
    io:println(n.toBalString()); // @output xml`foo`
    io:println(n is xml<never>); // @output false

    xml o = c + f;
    io:println(o.toBalString()); // @output xml`foo`
    io:println(o is xml<never>); // @output false
}

Test-Case: output
Description: Test value of empty xml (as xml<never>) and string concatentation using the exact static type.
Fail-Issue: ballerina-platform/ballerina-lang#32984
Labels: additive-expr, xml, xml-type-param, never, value:toBalString, string, is-expr, string:Char

function init() {
    string a = "";
    string:Char b = "b";
    xml<never> e = xml ``;

    xml:Text g = a + e;
    io:println(e.toBalString()); // @output xml``
    io:println(e is xml<never>); // @output true

    xml:Text j = b + e;
    io:println(j.toBalString()); // @output xml`b`
    io:println(j is xml<never>); // @output false
}

Test-Case: output
Description: Test xml concatenation for singleton value and non-empty string.
Labels: additive-expr, xml, string, value:toBalString

function init() {
    xml a = xml `foo`;
    xml b = xml `<!--bar-->`;
    xml c = xml `<baz/>`;
    xml d = xml `<?qux?>`;
    string e = "string value";

    xml f = a + e;
    io:println(f.toBalString()); // @output xml`foostring value`
    io:println(e + a); // @output string valuefoo

    f = e + b;
    io:println(f); // @output string value<!--bar-->
    io:println((b + e).toBalString()); // @output xml`<!--bar-->string value`

    f = c + e;
    io:println(f.toBalString()); // @output xml`<baz></baz>string value`
    io:println(e + c + e); // @output string value<baz></baz>string value

    f = d + e;
    io:println(f.toBalString()); // @output xml`<?qux ?>string value`
    io:println(e + d); // @output string value<?qux ?>
}

Test-Case: output
Description: Test xml and non-empty string concatenation with sequences.
Labels: additive-expr, xml, xml-type-param, xml:Element, xml:Comment, xml:ProcessingInstruction, xml:Text, string, value:toBalString

function init() {
    xml a = xml `foo`;
    xml b = xml `bar<!--bar-->`;
    xml<xml:Element|xml:ProcessingInstruction> c = xml `<baz/><?qux?>`;
    string d = "str";

    xml e = b + d;
    io:println(e.toBalString()); // @output xml`bar<!--bar-->str`
    io:println(e); // @output bar<!--bar-->str

    e = c + d;
    io:println(e); // @output <baz></baz><?qux ?>str
    io:println((d + c).toBalString()); // @output xml`str<baz></baz><?qux ?>`

    e = c + d + c;
    io:println(e); // @output <baz></baz><?qux ?>str<baz></baz><?qux ?>
    io:println(e.toBalString()); // @output xml`<baz></baz><?qux ?>str<baz></baz><?qux ?>`

    e = a + d + b + d;
    io:println(e.toBalString()); // @output xml`foostrbar<!--bar-->str`

    e = a + d + b + d + c;
    io:println(e); // @output foostrbar<!--bar-->str<baz></baz><?qux ?>
}

Test-Case: output
Description: Test xml concatenation with different subtypes of xml and string with a non-empty string as the string value.
Fail-Issue: ballerina-platform/ballerina-lang#32975
Labels: additive-expr, xml, string, xml-type-param, xml:Element, xml:Comment, xml:ProcessingInstruction, xml:Text, never, is-expr

function init() {
    xml:Text a = xml `foo`;
    xml:Comment b = xml `<!--bar-->`;
    xml:Element c = xml `<baz>baz value</baz>`;
    xml:ProcessingInstruction d = xml `<?qux val?>`;
    xml<xml:Text|xml:Comment> e = xml `<!--c1--> <!--c2-->`;
    string f = "barval";

    xml:Text h = a + f;
    io:println(h); // @output foobarval
    io:println(h is xml:Text); // @output true

    xml i = b + f;
    io:println(i); // @output <!--bar-->barval
    io:println(i is xml:Text); // @output false
    io:println(i is xml:Comment); // @output false
    io:println(i is xml<xml:Comment|xml:Text>); // @output true

    i = c + f;
    io:println(i); // @output <baz>baz value</baz>barval
    io:println(i is xml:Text); // @output false
    io:println(i is xml:Element); // @output false
    io:println(i is xml<xml:Element|xml:Text>); // @output true

    i = d + f;
    io:println(i); // @output <?qux val?>barval
    io:println(i is xml:Text); // @output false
    io:println(i is xml:ProcessingInstruction); // @output false
    io:println(i is xml<xml:ProcessingInstruction|xml:Text>); // @output true

    i = e + f;
    io:println(i); // @output <!--c1--> <!--c2-->barval
    io:println(i is xml:Text); // @output false
    io:println(i is xml<xml:Comment|xml:Text>); // @output true
}

Test-Case: output
Description: Test xml concatenation with different subtypes of xml and subtype of string with a non-empty string as the string value.
Fail-Issue: ballerina-platform/ballerina-lang#32975
Labels: additive-expr, xml, string:Char, xml-type-param, xml:Element, xml:Comment, xml:ProcessingInstruction, xml:Text, never, module-type-defn, union-type, is-expr

type Foo "fooval"|"";

function init() {
    xml:Text a = xml `foo`;
    xml:Comment b = xml `<!--bar-->`;
    xml:Element c = xml `<baz>baz value</baz>`;
    xml:ProcessingInstruction d = xml `<?qux val?>`;
    xml<xml:Text|xml:Comment> e = xml `<!--c1--> <!--c2-->`;
    string:Char f = "F";
    Foo g = "fooval";

    xml:Text h = a + f;
    io:println(h); // @output fooF
    io:println(h is xml:Text); // @output true

    h = a + g;
    io:println(h); // @output foofooval
    io:println(h is xml:Text); // @output true

    xml i = b + f;
    io:println(i); // @output <!--bar-->F
    io:println(i is xml:Text); // @output false
    io:println(i is xml:Comment); // @output false
    io:println(i is xml<xml:Comment|xml:Text>); // @output true

    i = b + g;
    io:println(i); // @output <!--bar-->fooval
    io:println(i is xml:Text); // @output false
    io:println(i is xml:Comment); // @output false
    io:println(i is xml<xml:Comment|xml:Text>); // @output true

    i = c + f;
    io:println(i); // @output <baz>baz value</baz>F
    io:println(i is xml:Text); // @output false
    io:println(i is xml:Element); // @output false
    io:println(i is xml<xml:Element|xml:Text>); // @output true

    i = c + g;
    io:println(i); // @output <baz>baz value</baz>fooval
    io:println(i is xml:Text); // @output false
    io:println(i is xml:Element); // @output false
    io:println(i is xml<xml:Element|xml:Text>); // @output true

    i = d + f;
    io:println(i); // @output <?qux val?>F
    io:println(i is xml:Text); // @output false
    io:println(i is xml:ProcessingInstruction); // @output false
    io:println(i is xml<xml:ProcessingInstruction|xml:Text>); // @output true

    i = g + d;
    io:println(i); // @output fooval<?qux val?>
    io:println(i is xml:Text); // @output false
    io:println(i is xml:ProcessingInstruction); // @output false
    io:println(i is xml<xml:ProcessingInstruction|xml:Text>); // @output true

    i = e + f;
    io:println(i); // @output <!--c1--> <!--c2-->F
    io:println(i is xml:Text); // @output false
    io:println(i is xml<xml:Comment|xml:Text>); // @output true

    i = g + e;
    io:println(i); // @output fooval<!--c1--> <!--c2-->
    io:println(i is xml:Text); // @output false
    io:println(i is xml<xml:Comment|xml:Text>); // @output true
}

Test-Case: output
Description: Test concatenation of empty xml sequence and non-empty string.
Labels: additive-expr, xml, xml-type-param, never, value:toBalString, string, is-expr

function init() {
    string a = "str";
    xml d = xml ``;
    xml<never> e = xml ``;

    xml f = a + d;
    io:println(f.toBalString()); // @output xml`str`
    io:println(f is xml:Text); // @output true
    io:println(f is xml<never>); // @output false

    f = a + e;
    io:println(f.toBalString()); // @output xml`str`
    io:println(f is xml:Text); // @output true
    io:println(f is xml<never>); // @output false
}

Test-Case: output
Description: Test concatenation of empty xml sequence and non-empty string.
Labels: additive-expr, xml, xml-type-param, never, value:toBalString, string:Char, module-type-defn, union-type, is-expr

type Foo ""|"foo";

function init() {
    Foo b = "foo";
    string:Char c = "C";
    xml d = xml ``;
    xml<never> e = xml ``;

    xml f = d + b;
    io:println(f.toBalString()); // @output xml`foo`
    io:println(f is xml:Text); // @output true
    io:println(f is xml<never>); // @output false

    f = e + b;
    io:println(f.toBalString()); // @output xml`foo`
    io:println(f is xml:Text); // @output true
    io:println(f is xml<never>); // @output false

    f = d + c;
    io:println(f.toBalString()); // @output xml`C`
    io:println(f is xml:Text); // @output true
    io:println(f is xml<never>); // @output false

    f = e + c;
    io:println(f.toBalString()); // @output xml`C`
    io:println(f is xml:Text); // @output true
    io:println(f is xml<never>); // @output false
}

Test-Case: output
Description: Test xml and string concatenation with xml and string literal expressions as operands.
Fail-Issue: ballerina-platform/ballerina-lang#32975
Labels: additive-expr, xml, int, string

function init() {
    int id = 21;
    io:println("hello" + xml `<count>${id}</count>`); // @output hello<count>21</count>
}

Test-Case: output
Description: Test xml and string concatenation with field access expressions as operands.
Labels: additive-expr, xml, field-access-expr, explicit-new-expr, module-class-defn, record-type

function init() {
    Bar b = {str: "value"};
    io:println(b.str + (new Foo()).id); // @output value<id>1234</id><default></default>
}

class Foo {
    xml id = xml `<id>1234</id><default/>`;
}

type Bar record {|
    string str;
|};

Test-Case: output
Description: Test xml and string concatenation with function call and method call expressions as operands.
Labels: additive-expr, xml, string, function-call-expr, method-call-expr, implicit-new-expr, explicit-new-expr, module-class-defn

function init() {
    Class cl = new;
    io:println(getXml() + cl.getXml()); // @output string value<!--Comment 1--> <!--Comment 2-->
    io:println(cl.getXml() + getXml()); // @output <!--Comment 1--> <!--Comment 2-->string value
    io:println(getXml() + getXml()); // @output string valuestring value
    io:println(cl.getXml() + (new Class()).getXml()); // @output <!--Comment 1--> <!--Comment 2--><!--Comment 1--> <!--Comment 2-->
}

function getXml() returns string {
    return "string value";
}

class Class {
    function getXml() returns xml<xml:Comment|xml:Text> {
        return xml `<!--Comment 1--> <!--Comment 2-->`;
    }
}

Test-Case: output
Description: Test xml and string concatenation with let expressions as operands.
Labels: additive-expr, xml, string:Char let-expr, xml:Element

function init() {
    xml s = (let string:Char c = "c", xml:Element b = xml `<def/>` in c + xml ` ` + b) + let string:Char v = "v" in v;
    io:println(s); // @output c <def></def>v
}

Test-Case: output
Description: Test xml and string concatenation with type cast expressions as operands.
Labels: additive-expr, xml, type-cast-expr, optional-type, xml:Element, module-type-defn, string-literal

type Foo "foo";

function init() {
    xml? s = xml `<elem/>`;
    Foo? t = "foo";
    io:println(<Foo> t + <xml> s); // @output foo<elem></elem>
}

Test-Case: output
Description: Test xml and string concatenation with additive expressions as operands.
Labels: additive-expr, xml, xml:Element, xml:Comment, xml:ProcessingInstruction, xml:Text, string

function init() {
    string r = "str";
    xml:Element s = xml `<elem>1234</elem>`;
    xml:Text t = xml `Hello World`;
    xml:ProcessingInstruction u = xml `<?pi 1?>`;
    xml:Comment v = xml `<!--comment 1-->`;
    xml w = xml `<foo/>1234<bar>1234</bar>`;

    xml x = (s + t + u + r) + v + r + w;
    io:println(x); // @output <elem>1234</elem>Hello World<?pi 1?>str<!--comment 1-->str<foo></foo>1234<bar>1234</bar>

    xml y = s + t + u + r + v + r + w;
    io:println(y); // @output <elem>1234</elem>Hello World<?pi 1?>str<!--comment 1-->str<foo></foo>1234<bar>1234</bar>

    xml z = (s + t) + u + r + v + r + w;
    io:println(z); // @output <elem>1234</elem>Hello World<?pi 1?>str<!--comment 1-->str<foo></foo>1234<bar>1234</bar>
}

Test-Case: output
Description: Test xml and string concatenation with conditional expressions as operands.
Labels: additive-expr, xml, union-expr, optional-type, error, conditional-expr, string:Char

function init() {
    xml? s = xml `foo`;
    string:Char|error t = "a";
    xml x = xml `<baz/>`;
    xml u = (s ?: x) + (t is error ? "foo" : t);
    io:println(u); // @output fooa
}

Test-Case: output
Description: Test xml and string concatenation with checking expressions as operands.
Labels: additive-expr, xml, string, union-expr, optional-type, error, check, checkpanic, value:toBalString

function init() returns error? {
    xml|error s = xml `hello`;
    string|error t = " world";

    xml u = check s + checkpanic t;
    io:println(u.toBalString()); // @output xml`hello world`
    io:println(check s + check t + checkpanic s); // @output hello worldhello
}
