Test-Case: parser-error
Description: Test list constructor negative syntax.
Labels: list-constructor-expr, array-type

function errorFunction() {
    int[] arr1 = [; // @error missing close bracket token
    int[] arr2 = ]; // @error missing open bracket token
    int[] arr3 = [
        1
        2 // @error missing comma token
        3 // @error missing comma token
    ];
}

Test-Case: output
Description: Test basic list constructor expression.
Labels: list-constructor-expr, string

function init() {
    io:println([]); // @output []
    io:println([1, 2, 3]); // @output [1,2,3]
    io:println(["A", 2, true]); // @output ["A",2,true]
}

Test-Case: output
Description: Test basic list constructor expression.
Labels: list-constructor-expr, string, array-type, tuple-type

function init() {
    int[] a1 = [1, 2, 3];
    io:println(a1); // @output [1,2,3]

    [int, string] a2 = [1,"foo"];
    io:println(a2); // @output [1,"foo"]
}

Test-Case: output
Description: Test list-constructor-expr creates a new list value.
Labels: list-constructor-expr, exact-equality

function init() {
    io:println([1, 2] === [1, 2]); // @output false
}

Test-Case: output
Description: Test members of the list come from evaluating each expression in the expr-list in order.
Labels: module-init-var-decl, list-constructor-expr, function-call-expr, array-type, additive-expr

int n = 0;

function init() {
    int[] arr = [foo(), foo(), foo()];
    io:println(arr); // @output [1,2,3]
}

function foo() returns int {
    n = n + 1;
    return n;
}

Test-Case: output
Description: Test list-constructor-expr occurring within a const-expr will construct a structural value
             that has its read-only bit on.
Fail-Issue: ballerina-platform/ballerina-lang#13944
Labels: module-const-decl, list-constructor-expr, is-expr, array-type, readonly-type, string

const string[] strArr = [];
const int[] intArr = [1, 2, 3, 4];

function init() {
    io:println(strArr is readonly); // @output true
    io:println(intArr is readonly); // @output true
}

Test-Case: output
Description: Test list-constructor-expr occurring within a const-expr will construct a structural value
             that has its read-only bit on.
Fail-Issue: ballerina-platform/ballerina-lang#13944
Labels: module-const-decl, list-constructor-expr, is-expr, tuple-type, readonly-type, string, boolean

const [int, string, boolean] tuple1 = [11, "foo", true];
const [int, [boolean, string], boolean] tuple2 = [11, [true, "foo"], true];

function init() {
    io:println(tuple1 is readonly); // @output true
    io:println(tuple2 is readonly); // @output true
}

Test-Case: output
Description: Test list-constructor-expr occurring within a const-expr will construct a structural value
             that has its read-only bit on.
Fail-Issue: ballerina-platform/ballerina-lang#13944
Labels: module-const-decl, list-constructor-expr, mapping-constructor-expr, member-access-expr, is-expr, array-type,
        map-type, readonly-type, string

const map<int[]> keyValues = {even: [2, 4, 6], odd: [1, 3, 5]};

function init() {
    io:println(keyValues["odd"] is readonly); // @output true
    io:println(keyValues["even"] is readonly); // @output true
}

Test-Case: output
Description: Test if there is a contextually expected type, then the inherent type of the newly created list
             is derived from the applicable contextually expected type
Labels: list-constructor-expr, byte, array-type, tuple-type, union-type, singleton-type, is-expr

function init() {
    int[] a1 = [1, 2, 3];
    io:println(a1 is int[]); // @output true
    io:println(a1 is byte[]); // @output false

    byte[] a2 = [1, 2, 3];
    io:println(a2 is byte[]); // @output true
    io:println(a2 is (1|2|3)[]); // @output false

    [int, byte, 3] a3 = [1, 2, 3];
    io:println(a3 is [int, byte, 3]); // @output true
    io:println(a3 is [int, 2, 3]); // @output false
}

Test-Case: output
Description: Test inherent type of the created list when the applicable contextually expected type
             is a list-type-descriptor of (any|error).
Fail-Issue: ballerina-platform/ballerina-lang#33377
Labels: list-constructor-expr, is-expr, any, union-type, array-type, string

function init() {
    any a1 = [];
    io:println(a1 is (any|error)[]); // @output true
    io:println(a1 is any[]); // @output false

    any a2 = [1, 2, 3];
    io:println(a2 is (any|error)[]); // @output true
    io:println(a2 is any[]); // @output false
    io:println(a2 is (any|error)[3]); // @output false

    any a3 = [1, "foo", false];
    io:println(a3 is (any|error)[]); // @output true
    io:println(a3 is any[]); // @output false
    io:println(a3 is (any|error)[3]); // @output false

    any[] a4 = [1, 2, 3];
    io:println(a4 is (any|error)[]); // @output true
    io:println(a4 is any[]); // @output false
    io:println(a4 is (any|error)[3]); // @output false

    any|any[] a5 = [1, 2, 3];
    io:println(a5 is (any|error)[]); // @output true
    io:println(a5 is any[]); // @output false
    io:println(a5 is (any|error)[3]); // @output false
}

Test-Case: output
Description: Test inherent type of the created list when the applicable contextually expected type
             is a list-type-descriptor with any members.
Labels: list-constructor-expr, is-expr, any, union-type, tuple-type, string, singleton-type

function init() {
    [any, any, any] t1 = [13, 25, "foo"];
    io:println(t1 is [any, any, any]); // @output true
    io:println(t1 is [13, 25, "foo"]); // @output false

    [any, any...] t2 = [11, 27, "foo", "bar"];
    io:println(t2 is [any, any...]); // @output true
    io:println(t2 is [any, any, any, any]); // @output false
    io:println(t2 is [13, 25, "foo"]); // @output false
}

Test-Case: output
Description: Test inherent type of the created list when the applicable contextually expected type
             is a list-type-descriptor of anydata.
Labels: list-constructor-expr, is-expr, anydata, union-type, array-type, string

function init() {
    anydata a1 = [];
    io:println(a1 is anydata[]); // @output true
    io:println(a1 is anydata[0]); // @output false

    anydata a2 = [1, 2, 3];
    io:println(a2 is anydata[]); // @output true
    io:println(a2 is anydata[3]); // @output false

    anydata a3 = [1, "foo", false];
    io:println(a3 is anydata[]); // @output true
    io:println(a3 is anydata[3]); // @output false

    anydata[] a4 = [1, 2, 3];
    io:println(a4 is anydata[]); // @output true
    io:println(a4 is anydata[3]); // @output false

    anydata|anydata[] a5 = [1, 2, 3];
    io:println(a5 is anydata[]); // @output true
    io:println(a5 is anydata[3]); // @output false
}

Test-Case: output
Description: Test inherent type of the created list when the applicable contextually expected type
             is a list-type-descriptor with anydata members.
Labels: list-constructor-expr, is-expr, anydata, union-type, tuple-type, string, singleton-type

function init() {
    [anydata, anydata, anydata] t1 = [13, 25, "foo"];
    io:println(t1 is [anydata, anydata, anydata]); // @output true
    io:println(t1 is [13, 25, "foo"]); // @output false

    [anydata, anydata...] t2 = [11, 27, "foo", "bar"];
    io:println(t2 is [anydata, anydata...]); // @output true
    io:println(t2 is [anydata, anydata, anydata, anydata]); // @output false
    io:println(t2 is [11, 27, "foo", "bar"]); // @output false
}

Test-Case: output
Description: Test inherent type of the created list when the applicable contextually expected type
             is a list-type-descriptor of json.
Labels: list-constructor-expr, is-expr, union-type, array-type, json, string

function init() {
    json a1 = [];
    io:println(a1 is json[]); // @output true
    io:println(a1 is json[0]); // @output false

    json a2 = [true, 2, "foo"];
    io:println(a2 is json[]); // @output true
    io:println(a2 is json[3]); // @output false

    json[] a3 = [true, 2, "foo"];
    io:println(a3 is json[]); // @output true
    io:println(a3 is json[3]); // @output false

    json|json[] a4 = [true, 2, "foo"];
    io:println(a4 is json[]); // @output true
    io:println(a4 is json[3]); // @output false
}

Test-Case: output
Description: Test inherent type of the created list when the applicable contextually expected type
             is a list-type-descriptor of json.
Labels: list-constructor-expr, is-expr, union-type, tuple-type, json, singleton-type, string

function init() {
    [json, json, json] t1 = [true, 2, "foo"];
    io:println(t1 is [json, json, json]); // @output true
    io:println(t1 is [true, 2, "foo"]); // @output false

    [json, json...] t2 = [true, 2, "foo"];
    io:println(t2 is [json, json...]); // @output true
    io:println(t2 is [json, json, json]); // @output false
    io:println(t2 is [true, 2, "foo"]); // @output false
}

Test-Case: output
Description: Test inherent type of the created list when the applicable contextually expected type
             is a list-type-descriptor with different types.
Labels: list-constructor-expr, is-expr, array-type, byte, float, decimal, FloatingPointTypeSuffix,
        DecimalFloatingPointNumber

function init() {
    int[] a1 = [];
    io:println(a1 is int[]); // @output true
    io:println(a1 is int[0]); // @output false

    int[] a2 = [1, 2, 3];
    io:println(a2 is int[]); // @output true
    io:println(a2 is int[3]); // @output false

    byte[] a3 = [17, 212, 33];
    io:println(a3 is byte[]); // @output true
    io:println(a3 is byte[3]); // @output false

    float[] a4 = [1, 2.0, 25e174, 0.3f];
    io:println(a4 is float[]); // @output true
    io:println(a4 is float[4]); // @output false

    decimal[] a5 = [9d, 21, 7e-56, 2.3];
    io:println(a5 is decimal[]); // @output true
    io:println(a5 is decimal[4]); // @output false

    int[][] a6 = [[0, 2, 3], [8, 1, 2], [7, 1, 1]];
    io:println(a6 is int[][]); // @output true
    io:println(a6 is int[3][3]); // @output false
}

Test-Case: output
Description: Test inherent type of the created list when the applicable contextually expected type
             is a list-type-descriptor with different types.
Labels: list-constructor-expr, is-expr, array-type, byte, boolean, union-type, singleton-type, DecimalNumber

function init() {
    byte[3] a1 = [17, 212, 33];
    io:println(a1 is byte[3]); // @output true
    io:println(a1 is (17|212|33)[3]); // @output false

    boolean[*] a2 = [true, true, false];
    io:println(a2 is boolean[3]); // @output true
    io:println(a2 is (true|false)[3]); // @output false
}

Test-Case: output
Description: Test inherent type of the created list when the applicable contextually expected type
             is a list-type-descriptor with different types.
Labels: list-constructor-expr, is-expr, tuple-type, byte, string, boolean, singleton-type, DecimalNumber

function init() {
    [int, int, int] t1 = [];
    io:println(t1 is [int, int, int]); // @output true

    [int...] t2 = [];
    io:println(t2 is [int...]); // @output true

    [int, int, int] t3 = [1, 2, 3];
    io:println(t3 is [int, int, int]); // @output true
    io:println(t3 is [1, 2, 3]); // @output false

    [int...] t4 = [1, 2, 3];
    io:println(t4 is [int...]); // @output true
    io:println(t4 is [int, int, int]); // @output false
    io:println(t4 is [1, 2, 3]); // @output false

    [byte, byte, byte] t5 = [17, 212, 33];
    io:println(t5 is [byte, byte, byte]); // @output true
    io:println(t5 is [17, 212, 33]); // @output false

    [byte, byte...] t6 = [17, 212, 33];
    io:println(t6 is [byte, byte...]); // @output true
    io:println(t6 is [byte, byte, byte]); // @output false
    io:println(t6 is [17, 212, 33]); // @output false

    [int, int, string] t7 = [1, 2, "foo"];
    io:println(t7 is [int, int, string]); // @output true
    io:println(t7 is [1, 2, "foo"]); // @output false

    [int, [boolean, string], boolean] t8 = [11, [true, "foo"], true];
    io:println(t8 is [int, [boolean, string], boolean]); // @output true
    io:println(t8 is [11, [true, "foo"], true]); // @output false

    [int, string...] t9 = [12, "foo", "bar", "baz"];
    io:println(t9 is [int, string...]); // @output true
    io:println(t9 is [int, string, string, string]); // @output false
    io:println(t9 is [12, "foo", "bar", "baz"]); // @output false
}

Test-Case: output
Description: Test inherent type of the created list when the applicable contextually expected type
             is a list-type-descriptor with different types.
Labels: list-constructor-expr, is-expr, array-type, tuple-type, string, boolean, singleton-type, DecimalNumber

function init() {
    [int, string][] a1 = [[1, "foo"], [2, "bar"], [3, "baz"]];
    io:println(a1 is [int, string][]); // @output true
    io:println(a1 is [int, string][3]); // @output false
    io:println(a1 is [[1, "foo"], [2, "bar"], [3, "baz"]]); // @output false

    [int, string[2], boolean] t1 = [1, ["foo", "bar"], true];
    io:println(t1 is [int, string[2], boolean]); // @output true
    io:println(t1 is [1, ["foo", "bar"], true]); // @output false

    [int, [int, string...], int] t2 = [12, [2, "bar", "qux", "quux"], 21];
    io:println(t2 is [int, [int, string...], int]); // @output true
    io:println(t2 is [int, [int, string, string, string], int]); // @output false
    io:println(t2 is [12, [2, "bar", "qux", "quux"], 21]); // @output false
}

Test-Case: output
Description: Test inherent type of the created list when the applicable contextually expected type
             is a readonly list-type-descriptor.
Labels: list-constructor-expr, is-expr, array-type, tuple-type, readonly-type, intersection-type, string,
        singleton-type, DecimalNumber

function init() {
    readonly & int[] a1 = [1, 2, 3];
    io:println(a1 is [1, 2, 3]); // @output true
    io:println(a1 is readonly); // @output true

    readonly & [int, string, int] t1 = [33, "foo", 17];
    io:println(t1 is [33, "foo", 17]); // @output true
    io:println(t1 is readonly); // @output true
}

Test-Case: output
Description: Test inherent type of the created list when the applicable contextually expected type
             is a list-type-descriptor with optional types.
Labels: list-constructor-expr, is-expr, array-type, optional-type, union-type, string, boolean, nil-literal, nil-type

function init() {
    int?[] a1 = [1, 2, 3];
    io:println(a1 is int?[]); // @output true
    io:println(a1 is int[]); // @output false

    int?[] a2 = [1, (), 3];
    io:println(a2 is int?[]); // @output true
    io:println(a2 is int[]); // @output false

    int[]? a3 = [1, 2, 3];
    io:println(a3 is int[]); // @output true
    io:println(a3 is int[3]); // @output false

    int?[]? a4 = [(), (), ()];
    io:println(a4 is int?[]); // @output true
    io:println(a4 is ()[]); // @output false

    (int?|boolean?|string?)[] a5 = [43, false, "foo"];
    io:println(a5 is (int|boolean|string)?[]); // @output true
    io:println(a5 is (int|boolean|string)?[3]); // @output false
    io:println(a5 is (int|boolean|string)[]); // @output false
    io:println(a5 is ()[]); // @output false
}

Test-Case: output
Description: Test inherent type of the created list when the applicable contextually expected type
             is a list-type-descriptor with optional types.
Labels: list-constructor-expr, is-expr, tuple-type, optional-type, union-type, string, boolean, nil-literal,
        nil-type, singleton-type

function init() {
    [int?, boolean?, string?] t1 = [11, false, "foo"];
    io:println(t1 is [int?, boolean?, string?]); // @output true
    io:println(t1 is [int, boolean, string]); // @output false

    [int?, boolean?, string?] t2 = [(), (), ()];
    io:println(t2 is [int?, boolean?, string?]); // @output true
    io:println(t2 is [(), (), ()]); // @output false

    [int?, boolean?, string?]? t3 = [11, false, "foo"];
    io:println(t3 is [int?, boolean?, string?]); // @output true
    io:println(t3 is [int, boolean, string]); // @output false
    io:println(t3 is [11, false, "foo"]); // @output false

    [int?|boolean?, boolean?, string|int?] t4 = [true, false, "foo"];
    io:println(t4 is [(int|boolean)?, boolean?, (string|int)?]); // @output true
    io:println(t4 is [int|boolean, boolean, string|int]); // @output false
    io:println(t4 is [true, false, "foo"]); // @output false

    [int?, [boolean?, string?|boolean], boolean?] t5 = [11, [true, ()], true];
    io:println(t5 is [int?, [boolean?, (string|boolean)?], boolean?]); // @output true
    io:println(t5 is [int, [boolean, (string|boolean)?], boolean]); // @output false
    io:println(t5 is [11, [true, ()], true]); // @output false
}

Test-Case: output
Description: Test inherent type of the created list when the applicable contextually expected type
             is a list-type-descriptor of union.
Labels: list-constructor-expr, is-expr, array-type, union-type, string, decimal, boolean, byte,
        singleton-type, DecimalNumber, DecimalFloatingPointNumber

function init() {
    (int|string|decimal|boolean)[] a1 = [2.0, "foo", false, true];
    io:println(a1 is (int|string|decimal|boolean)[]); // @output true
    io:println(a1 is (string|decimal|boolean)[]); // @output false

    (int|byte)[] a2 = [1, 2, 3];
    io:println(a2 is (int|byte)[]); // @output true
    io:println(a2 is byte[]); // @output false
    io:println(a2 is int[3]); // @output false
}

Test-Case: output
Description: Test inherent type of the created list when the applicable contextually expected type
             is a list-type-descriptor of union.
Labels: list-constructor-expr, is-expr, tuple-type, union-type, string, decimal, boolean, DecimalFloatingPointNumber

function init() {
    [int|string|decimal|boolean, string, boolean|int] t1 = [2.0, "foo", false];
    io:println(t1 is [(int|string|decimal|boolean), string, (boolean|int)]); // @output true
    io:println(t1 is [decimal, string, boolean]); // @output false

    [int|string, boolean|string...] t2 = [23, "foo", false, "bar", true];
    io:println(t2 is [(int|string), (boolean|string)...]); // @output true
    io:println(t2 is [int, string, boolean, string, boolean]); // @output false
}

Test-Case: output
Description: Test inherent type of the created list when the applicable contextually expected type
             is a list-type-descriptor of union.
Labels: list-constructor-expr, is-expr, array-type, tuple-type, union-type, byte,
        singleton-type, DecimalNumber, DecimalFloatingPointNumber

function init() {
    [int, (int|byte)[]] t1 = [17, [23, 700]];
    io:println(t1 is [int, (int|byte)[]]); // @output true
    io:println(t1 is [int, byte[]]); // @output false
    io:println(t1 is [17, [23, 700]]); // @output false

    [int, (int|byte)[]...] t2 = [17, [23, 700]];
    io:println(t2 is [int, (int|byte)[]...]); // @output true
    io:println(t2 is [int, (int|byte)[]]); // @output false
    io:println(t2 is [17, [23, 700]]); // @output false

    [(int|byte)[], int] t3 = [[23, 700], 17];
    io:println(t3 is [(int|byte)[], int]); // @output true
    io:println(t3 is [[byte, int], int]); // @output false
    io:println(t3 is [[23, 700], 17]); // @output false

    [((int|byte)[])...] t4 = [[17], [23, 700]];
    io:println(t4 is [((int|byte)[])...]); // @output true
    io:println(t4 is [((int|byte)[]), ((int|byte)[])]); // @output false
    io:println(t4 is [[17], [23, 700]]); // @output false

    [(int|byte)[], (boolean|string)[]...] t5 = [[23, 700, 252, 0], ["foo", false, "bar", true], [true], ["qux", "quux"]];
    io:println(t5 is [(int|byte)[], (boolean|string)[]...]); // @output true
    io:println(t5 is [(int|byte)[], (boolean|string)[], (boolean|string)[], (boolean|string)[]]); // @output false
    io:println(t5 is [[23, 700, 252, 0], ["foo", false, "bar", true], [true], ["qux", "quux"]]); // @output false

    [(int|byte)[]...] t6 = [[17], [23, 700]];
    io:println(t6 is [(int|byte)[]...]); // @output true
    io:println(t6 is [(int|byte)[], (int|byte)[]]); // @output false
    io:println(t6 is [[17], [23, 700]]); // @output false
}

Test-Case: output
Description: Test inherent type of the created list when the applicable contextually expected type
             is a list-type-descriptor of user-defined type.
Labels: module-type-defn, list-constructor-expr, is-expr, array-type, union-type, singleton-type,
        DecimalNumber

type Ints 0|1|2|3;

function init() {
    Ints[] a1 = [1, 3, 0];
    io:println(a1 is Ints[]); // @output true
    io:println(a1 is (0|1|3)[]); // @output false
    io:println(a1 is [1, 3, 0]); // @output false
}

Test-Case: output
Description: Test inherent type of the created list when the applicable contextually expected type
             is a list-type-descriptor of user-defined type.
Labels: module-type-defn, list-constructor-expr, is-expr, tuple-type, union-type, singleton-type, DecimalNumber, boolean

type Ints 0|1|2|3;

function init() {
    [Ints, Ints, boolean] t1 = [2, 0, true];
    io:println(t1 is [Ints, Ints, boolean]); // @output true
    io:println(t1 is [0|2, 0|2, boolean]); // @output false
    io:println(t1 is [2, 0, true]); // @output false
}

Test-Case: output
Description: Test inherent type of the created list when the applicable contextually expected type
             is a list-type-descriptor of record or map.
Labels: module-type-defn, list-constructor-expr, mapping-constructor-expr, is-expr, array-type, map-type, string,
        record-type, singleton-type

type Student record {|
    int id;
    string name;
    int age;
|};

function init() {
    Student[] a1 = [{id: 111, name: "Mike", age: 15}, {id: 99, name: "Emma", age: 17}];
    io:println(a1 is Student[]); // @output true
    io:println(a1 is Student[2]); // @output false

    map<string>[] a2 = [{firstName: "Joey", lastName: "Tribbiani"}, {firstName: "Monica", lastName: "Geller"}];
    io:println(a2 is map<string>[]); // @output true
    io:println(a2 is map<string>[2]); // @output false
    io:println(a2 is map<"Joey"|"Tribbiani"|"Monica"|"Geller">[]); // @output false
}

Test-Case: output
Description: Test inherent type of the created list when the applicable contextually expected type
             is a list-type-descriptor of record or map.
Labels: module-type-defn, list-constructor-expr, mapping-constructor-expr, is-expr, tuple-type, map-type, string,
        record-type, singleton-type

type Student record {|
    int id;
    string name;
    int age;
|};

function init() {
    [Student...] t1 = [{id: 111, name: "Mike", age: 15}, {id: 99, name: "Emma", age: 17}];
    io:println(t1 is [Student...]); // @output true
    io:println(t1 is [Student, Student]); // @output false

    [map<string>, map<int>] t2 = [{firstName: "Ross", lastName: "Geller"}, {circles: 12, rectangles: 7}];
    io:println(t2 is [map<string>, map<int>]); // @output true
    io:println(t2 is [map<"Ross"|"Geller">, map<12|7>]); // @output false
}

Test-Case: output
Description: Test inherent type of the created list when the applicable contextually expected type
             is a list-type-descriptor, where the contextually expected type is a union.
Labels: list-constructor-expr, is-expr, array-type, union-type, byte, decimal, string, singleton-type, DecimalNumber

function init() {
    int[]|int|byte|decimal a1 = [1, 2, 3];
    io:println(a1 is int[]); // @output true
    io:println(a1 is (1|2|3)[]); // @output false
    io:println(a1 is int[3]); // @output false
}

Test-Case: output
Description: Test inherent type of the created list when the applicable contextually expected type
             is a list-type-descriptor, where the contextually expected type is a union.
Labels: list-constructor-expr, is-expr, tuple-type, union-type, byte, decimal, string

function init() {
    [int, string, int]|int|byte|decimal t1 = [34, "foo", 13];
    io:println(t1 is [int, string, int]); // @output true
    io:println(t1 is [byte, string, byte]); // @output false
}

Test-Case: output
Description: Test the applicable contextually expected type being a union type descriptor,
             where any members of the union that do not contain list shapes of length N is ignored.
Labels: list-constructor-expr, is-expr, array-type, union-type, byte, singleton-type, DecimalNumber

function init() {
    int[2]|int[3]|byte[] a1 = [1, 2, 3, 4];
    io:println(a1 is byte[]); // @output true
    io:println(a1 is byte[4]); // @output false
    io:println(a1 is (1|2|3|4)[]); // @output false

    int[2]|int[3]|int[*] a2 = [1, 2, 3, 4];
    io:println(a2 is int[4]); // @output true
    io:println(a2 is byte[4]); // @output false

    int[2]|int[3]|int[]|int|byte a3 = [1, 2, 3, 4];
    io:println(a3 is int[]); // @output true
    io:println(a3 is int[4]); // @output false
    io:println(a3 is byte[]); // @output false
}

Test-Case: output
Description: Test the applicable contextually expected type being a union type descriptor,
             where any members of the union that do not contain list shapes of length N is ignored.
Labels: list-constructor-expr, is-expr, tuple-type, union-type, byte

function init() {
    [int]|[int, int]|[int, int, int] t1 = [1, 2, 3];
    io:println(t1 is [int, int, int]); // @output true
    io:println(t1 is [byte, byte, byte]); // @output false

    [int]|[int, int]|int|byte t2 = [1, 2];
    io:println(t2 is [int, int]); // @output true
    io:println(t2 is [byte, byte]); // @output false

    [int...]|int|byte t3 = [1, 2];
    io:println(t3 is [int...]); // @output true
    io:println(t3 is [int, int]); // @output false
    io:println(t3 is [byte...]); // @output false
}

Test-Case: error
Description: Test the compile-time error when the applicable contextually expected type does not leave
             a single list type descriptor.
Labels: list-constructor-expr, array-type, tuple-type, union-type

function errorFunction() {
    int[4]|int[3] _ = [1, 2, 3]; // @error ambiguous type '(int[4]|int[3])'
    [int, int, int]|[int] _ = [1]; // @error ambiguous type '([int,int,int]|[int])'

    int[2]|[int, int, int] _ = [1, 2]; // @error ambiguous type '(int[2]|[int,int,int])'
    int[3]|[int, int] _ = [1, 2]; // @error ambiguous type '(int[3]|[int,int])'

    ([int]|[int, int])[] _ = [[1], [1, 2]]; // @error ambiguous type '([int]|[int,int])'
}

Test-Case: error
Description: Test the compile-time error when the applicable contextually expected type does not leave
             a single list type descriptor.
Labels: list-constructor-expr, array-type, tuple-type, union-type, byte, string, boolean

function errorFunction() {
    int[]|int[3] _ = [1, 2]; // @error ambiguous type '(int[]|int[3])'
    int[]|int[3] _ = [1, 2, 3]; // @error ambiguous type '(int[]|int[3])'
    int[]|byte[] _ = [1, 2, 3]; // @error ambiguous type '(int[]|byte[])'

    int[2]|int[3] _ = [12]; // @error ambiguous type '(int[2]|int[3])'

    [int...]|[int, int, int] _ = [1, 2]; // @error ambiguous type '([int...]|[int,int,int])'
    [int...]|[int, int, int] _ = [1, 2, 3]; // @error ambiguous type '([int...]|[int,int,int])'
    [int...]|[byte...] _ = [1, 2, 3]; // @error ambiguous type '([int...]|[byte...])'

    [int, int]|[int, int, int] _ = [1]; // @error ambiguous type '([int,int]|[int,int,int])'

    int[]|[int, int, int] _ = [1, 2]; // @error ambiguous type '(int[]|[int,int,int])'
    int[]|[int, int, int] _ = [1, 2, 3]; // @error ambiguous type '(int[]|[int,int,int])'
    int[]|[byte...] _ = [1, 2, 3]; // @error ambiguous type '(int[]|[byte...])'

    int[2]|[int, int, int] _ = [1]; // @error ambiguous type '(int[2]|[int,int,int])'

    int[]|int[3]|boolean[] _ = [1, 2, 3]; // @error ambiguous type '(int[]|int[3]|boolean[])'
    int|string|boolean _ = [1, 2, 3]; // @error incompatible types: expected '(int|string|boolean)', found '[int,int,int]'
}

Test-Case: error
Description: Test the compile-time error when the applicable contextually expected type does not leave
             a single list type descriptor.
Fail-Issue: ballerina-platform/ballerina-lang#33056
Labels: list-constructor-expr, array-type, tuple-type, union-type, byte, string, boolean

function errorFunction() {
    string[]|int[]|boolean[] _ = [1, 2, 3]; // @error inherent type cannot be a union type
    string[]|int[] _ = [1, 2, 3]; // @error inherent type cannot be a union type

    [int, int, int]|[string...] _ = [1, 2, 3]; // @error inherent type cannot be a union type
    [int, int, int]|[string...]|int|boolean _ = [1, 2, 3]; // @error inherent type cannot be a union type

    [int, int, int]|boolean[] _ = [1, 2, 3]; // @error inherent type cannot be a union type
    int[]|[boolean] _ = [1, 2, 3]; // @error inherent type cannot be a union type
}

Test-Case: output
Description: Test when there is no contextually expected type, then the inherent type is a a tuple-type-descriptor
             with a member-type-descriptor for each expression in the expr-list,
             where the type of each member-type-descriptor will be the broad type of the corresponding expression
             in the expr-list.
Labels: list-constructor-expr, is-expr, var, boolean-literal, singleton-type, DecimalNumber, tuple-type, string

function init() {
    var a1 = [1, 2, 3];
    io:println(a1 is [int, int, int]); // @output true
    io:println(a1 is [byte, byte, byte]); // @output false

    var a2 = [1, "foo", "bar", 3];
    io:println(a2 is [int, string, string, int]); // @output true
    io:println(a2 is [byte, "foo", "bar", byte]); // @output false

    var a3 = [1, ["foo", [true, 23]], [true, false, true]];
    io:println(a3 is [int, [string, [boolean, int]], [boolean, boolean, boolean]]); // @output true
    io:println(a3 is [1, ["foo", [true, 23]], [true, false, true]]); // @output false

    io:println([1, 2, 3] is [int, int, int]); // @output true
    io:println([1, 2, 3] is [1, 2, 3]); // @output false

    io:println([1, "foo", "bar", 3] is [int, string, string, int]); // @output true
    io:println([1, "foo", "bar", 3] is [1, "foo", "bar", 3]); // @output false

    io:println([1, ["foo", [true, 23]], [true, false, true]] is [int, [string, [boolean, int]], [boolean, boolean, boolean]]); // @output true
    io:println([1, ["foo", [true, 23]], [true, false, true]] is [1, ["foo", [true, 23]], [true, false, true]]); // @output false
}

Test-Case: error
Description: Test when there is a contextually expected type, then the type that the inherent type
             requires for each list member provides the contextually expected type for the expression for the member.
Labels: list-constructor-expr, member-access-expr, array-type, DecimalFloatingPointNumber, byte, float, union-type,
        optional-type, unary-minus

function errorFunction() {
    byte[] a1 = [1, 2, 3];

    a1[0] = 333; // @error incompatible types: expected 'byte', found 'int'
    a1[1] = -2; // @error incompatible types: expected 'byte', found 'int'
    a1[2] = 2.3; // @error incompatible types: expected 'byte', found 'float'

    int?[] a2 = [1, 2, 3];

    a2[0] = true; // @error incompatible types: expected 'int?', found 'boolean'
    a2[1] = 1.2; // @error incompatible types: expected 'int?', found 'float'
    a2[2] = false; // @error incompatible types: expected 'int?', found 'boolean'

    (byte|string)[] a3 = [1, 2, 3];

    a3[0] = 400; // @error incompatible types: expected '(byte|string)', found 'int'
    a3[1] = 1.2; // @error incompatible types: expected '(int|string)', found 'float'
    a3[2] = false; // @error incompatible types: expected '(int|string)', found 'boolean'
}

Test-Case: error
Description: Test when there is a contextually expected type, then the type that the inherent type
             requires for each list member provides the contextually expected type for the expression for the member.
Labels: list-constructor-expr, member-access-expr, array-type, byte, string, singleton-type, union-type

function errorFunction() {
    [true, byte, "foo"|"bar"] t1 = [true, 2, "foo"];

    t1[0] = false; // @error incompatible types: expected 'true', found 'boolean'
    t1[1] = 522; // @error incompatible types: expected 'byte', found 'int'
    t1[2] = "baz"; // @error incompatible types: expected 'foo|bar', found 'string'

    [int, string?...] t2 = [1, "foo", "bar"];

    t2[0] = true; // @error incompatible types: expected 'int', found 'boolean'
    t2[1] = 12; // @error incompatible types: expected 'string?', found 'int'
    t2[2] = false; // @error incompatible types: expected 'string?', found 'boolean'

    [int, string|int, string?|int] t3 = [1, "foo", "bar"];

    t3[0] = true; // @error incompatible types: expected 'int', found 'boolean'
    t3[1] = false; // @error incompatible types: expected '(string|int)', found 'boolean'
    t3[2] = false; // @error incompatible types: expected '(string|int)?', found 'boolean'
}

Test-Case: output
Description: Test a member of list being able to fill automatically when the FillMember abstract operation succeed on it.
Labels: list-constructor-expr, array-type

function init() {
    int[5] a1 = [1, 2, 3];
    io:println(a1); // @output [1,2,3,0,0]
}

Test-Case: output
Description: Test a member of list being able to fill automatically when the FillMember abstract operation succeed on it.
Labels: list-constructor-expr, tuple-type, string, boolean

function init() {
    [int, string, int, boolean] t1 = [1, "foo"];
    io:println(t1); // @output [1,"foo",0,false]
}

Test-Case: error
Description: Test a member of list being unable to fill automatically as the FillMember abstract operation fails on it.
Labels: list-constructor-expr, array-type, union-type, string

function errorFunction() {
    (int|string)[4] _ = [1, 2]; // @error invalid usage of list constructor: type '(int|string)[4]' does not have a filler value
}

Test-Case: error
Description: Test a member of list being  unable to fill automatically as the FillMember abstract operation fails on it.
Labels: list-constructor-expr, tuple-type, union-type, boolean, string

function errorFunction() {
    [int,boolean|string] _ = [1]; // @error tuple and expression size does not match
}

Test-Case: output
Description: Test list-constructor-expr in module-var-decl.
Labels: module-init-var-decl, list-constructor-expr, is-expr, array-type, byte

int[] a1 = [1, 2, 3];
int[][] a2 = [[0, 2, 3], [8, 1, 2], [7, 1, 1]];

function init() {
    io:println(a1 is int[]); // @output true
    io:println(a1 is int[3]); // @output false
    io:println(a1 is byte[]); // @output false

    io:println(a2 is int[][]); // @output true
    io:println(a2 is int[3][3]); // @output false
    io:println(a2 is byte[][]); // @output false
}

Test-Case: output
Description: Test list-constructor-expr in module-var-decl.
Labels: module-init-var-decl, list-constructor-expr, is-expr, tuple-type, byte

[int, int, int] t1 = [1, 2, 3];
[int...] t2 = [1, 2, 3];

function init() {
    io:println(t1 is [int, int, int]); // @output true
    io:println(t1 is [byte, byte, byte]); // @output false

    io:println(t2 is [int...]); // @output true
    io:println(t2 is [int, int, int]); // @output false
    io:println(t2 is [byte...]); // @output false
}

Test-Case: output
Description: Test list-constructor-expr in module-var-decl.
Labels: module-init-var-decl, list-constructor-expr, is-expr, array-type, tuple-type, union-type, byte, boolean,
        string

[(int|byte)[], int] t1 = [[23, 700], 17];
[(int|byte)[]...] t2 = [[17], [23, 700]];
[(int|byte)[], (boolean|string)[]...] t3 = [[23, 700, 252, 0], ["foo", false, "bar", true], [true], ["qux", "quux"]];

function init() {
    io:println(t1 is [(int|byte)[], int]); // @output true
    io:println(t1 is [(int|byte)[1], int]); // @output false
    io:println(t1 is [byte[], int]); // @output false

    io:println(t2 is [(int|byte)[]...]); // @output true
    io:println(t2 is [(int|byte)[], (int|byte)[]]); // @output false
    io:println(t2 is [byte[]...]); // @output false

    io:println(t3 is [(int|byte)[], (boolean|string)[]...]); // @output true
    io:println(t3 is [byte[], (boolean|string)[]...]); // @output false
    io:println(t3 is [(int|byte)[], (boolean|string)[], (boolean|string)[]]); // @output false
}

Test-Case: output
Description: Test literals as list-constructor expressions.
Labels: list-constructor-expr, is-expr, HexFloatingPointLiteral, DecimalFloatingPointNumber, FloatingPointTypeSuffix,
        singleton-type, byte-array-literal, decimal, boolean, string, byte, float, nil-literal, nil-type, tuple-type

function init() {
    io:println([11, 2.0, true, base64 `bGlnaHQgd29y`, (), "foo", 0x12, 7e-56, 0X21.5, 3.9] is [int, float, boolean, byte[], (), string, int, float, float, float]); // @output true
    io:println([11, 2.0, true, base64 `bGlnaHQgd29y`, (), "foo", 0x12, 7e-56, 0X21.5, 3.9] is [11, 2.0, true, byte[], (), "foo", 0x12, 7e-56, 0X21.5, 3.9]); // @output false
}

Test-Case: output
Description: Test string-template-expr as list-constructor expressions.
Labels: list-constructor-expr, is-expr, singleton-type, string, BacktickString, tuple-type

function init() {
    io:println([string `Hello ${10 * 3}!!`, "foo", string `\u{61}NT`, "bar"] is [string, string, string, string]); // @output true
    io:println([string `Hello ${10 * 3}!!`, "foo", string `\u{61}NT`, "bar"] is ["Hello 30!!", "foo", "\u{61}NT", "bar"]); // @output false
}

Test-Case: output
Description: Test xml-template-expr as list-constructor expressions.
Labels: list-constructor-expr, is-expr, tuple-type, BacktickString, xml, xml:Element, xml:Text, xml:Comment

function init() {
    io:println([xml `<name>Mike</name>`, xml `${7 + 3}`, xml `<!-- hello -->`] is [xml:Element, xml:Text, xml:Comment]); // @output true
}

Test-Case: output
Description: Test raw-template-expr as list-constructor expressions.
Labels: list-constructor-expr, is-expr, tuple-type, raw-template-expr, object:RawTemplate

function init() {
    io:println([`x + y = ${2 + 3}`, `Count:${1}`, `INSERT INTO Details VALUES (${"Foo"}, ${20})`] is [object:RawTemplate, object:RawTemplate, object:RawTemplate]); // @output true
}

Test-Case: output
Description: Test structural-constructor-expr as list-constructor expressions.
Labels: list-constructor-expr, table-constructor-expr, mapping-constructor-expr, tuple-type, string, record-type, table-type

function init() {
    io:println([
        [23, "foo"],
        table key(id) [
                {id: 1, name: "Frank", age: 54},
                {id: 2, name: "John", age: 47}
            ],
        {a: 1, b: "bar", c: true}
    ] is [[int, string], table<record {|readonly int id; string name; int age;|}> key(id), record {|int a; string b; boolean c;|}]); // @output true
}

Test-Case: output
Description: Test object-constructor-expr as list-constructor expressions.
Labels: list-constructor-expr, is-expr, object-constructor-expr, array-type

function init() {
    io:println([
        object {
            int i;
            function init() {
                self.i = 20;
            }
        },
        object {
            int a;
            string[] b;

            function init() {
                self.a = 21;
                self.b = [];
            }
        },
        object {}
    ] is object {}[]); // @output true
}

Test-Case: output
Description: Test as new-expr list-constructor expressions.
Labels: list-constructor-expr, is-expr, implicit-new-expr, explicit-new-expr, new-expr, module-class-defn, array-type

class Student {
    int i;

    function init() {
        self.i = 0;
    }
}

function init() {
    Student[] arr = [new, new Student()];

    io:println(arr is Student[]); // @output true
}

Test-Case: output
Description: Test variable-reference-expr as list-constructor expressions.
Labels: list-constructor-expr, is-expr, string, decimal, DecimalFloatingPointNumber, tuple-type, array-type, singleton-type

function init() {
    string name = "Ballerina";
    decimal ver = 2.0;
    string[] arr = ["R", "O", "X"];

    io:println([name, ver, arr] is [string, decimal, string[]]); // @output true
    io:println([name, ver, arr] is ["Ballerina", decimal, string[]]); // @output false
}

Test-Case: output
Description: Test field-access-expr as list-constructor expressions.
Labels: list-constructor-expr,  mapping-constructor-expr, field-access-expr, is-expr, module-type-defn, record-type,
        string, singleton-type, DecimalNumber, tuple-type

type Employee record {|
    int id;
    string name;
|};

function init() {
    Employee emp = {id: 0, name: "John"};

    io:println([emp.id, emp.name] is [int, string]); // @output true
    io:println([emp.id, emp.name] is [0, "John"]); // @output false
}

Test-Case: output
Description: Test optional-field-access as list-constructor expressions.
Labels: list-constructor-expr, mapping-constructor-expr, optional-field-access-expr, is-expr, module-type-defn,
        record-type, string, singleton-type, optional-type, tuple-type

type Employee record {|
    int id;
    string fName;
    string lName?;
|};

function init() {
    Employee emp = {id: 0, fName: "Ross", lName: "Geller"};

    io:println([emp?.id, emp?.fName, emp?.lName] is [int, string, string?]); // @output true
    io:println([emp?.id, emp?.fName, emp?.lName] is [int, string, string]); // @output false
    io:println([emp?.id, emp?.fName, emp?.lName] is [int, "Ross", "Geller"?]); // @output false
}

Test-Case: output
Description: Test annot-access-expr as list-constructor expressions.
Labels: list-constructor-expr, annotation-decl, module-type-defn, record-type, string, mapping-constructor-expr,
        typedesc-type, annot-access-expr, singleton-type, optional-type, is-expr, tuple-type

annotation v1 on type;

annotation v2 on type;

@v1
type T1 record {
    string name;
};

T1 t1 = {name: "Ross"};

function init() {
    typedesc<T1> t = typeof t1;

    io:println([t.@v1, t.@v2] is [true?, true?]); // @output true
    io:println([t.@v1, t.@v2] is [true, true]); // @output false
}

Test-Case: output
Description: Test member-access-expr as list-constructor expressions.
Labels: list-constructor-expr, member-access-expr, is-expr, array-type, byte

function init() {
    int[] arr = [1, 2, 3, 4, 5];

    io:println(arr[0] is 1); // @output true
    io:println(arr[1] is 2); // @output true
    io:println(arr[2] is 3); // @output true
    io:println(arr[3] is 4); // @output true
    io:println(arr[4] is 5); // @output true
}

Test-Case: output
Description: Test function-call-expr as list-constructor expressions.
Labels: list-constructor-expr, function-call-expr, is-expr, boolean, singleton-type, tuple-type

function init() {
    io:println([isSameNumber(3, 2), isSameNumber(4, 4)] is [boolean, boolean]); // @output true
    io:println([isSameNumber(3, 2), isSameNumber(4, 4)] is [false, true]); // @output false
}

function isSameNumber(int a, int b) returns boolean {
    return a == b;
}

Test-Case: output
Description: Test method-call-expr as list-constructor expressions.
Labels: list-constructor-expr, method-call-expr, is-expr, value:toString, tuple-type, singleton-type, string

function init() {
    io:println(["Hello".toString(), "World".toString()] is [string, string]); // @output true
    io:println(["Hello".toString(), "World".toString()] is ["Hello", "World"]); // @output false
}

Test-Case: output
Description: Test error-constructor-expr as list-constructor expressions.
Labels: list-constructor-expr, error-constructor-expr, is-expr, error-type, tuple-type

function init() {
    io:println([error("Oh, NO!"), error("OMG!")] is [error,error]); // @output true
}

Test-Case: output
Description: Test anonymous-function-expr as list-constructor expressions.
Labels: list-constructor-expr, explicit-anonymous-function-expr, infer-anonymous-function-expr, is-expr,
        module-type-defn, byte, array-type, function-type

type func function () returns int;

function init() {
    func[] arr = [
        function() returns byte {
            return 5;
        },
        () => 10
    ];

    io:println(arr is (function () returns int)[]); // @output true
    io:println(arr is (function () returns byte)[]); // @output false
}

Test-Case: output
Description: Test let-expr as list-constructor expressions.
Labels: list-constructor-expr, let-expr, is-expr, boolean, singleton-type, tuple-type, multiplicative-expr

function init() {
    io:println([
        let int i = 4
            in i * 2,
        let int x = 3
            in x == 3
    ] is [int, boolean]); // @output true

    io:println([
        let int i = 4
            in i * 2,
        let int x = 3
            in x == 3
    ] is [8, true]); // @output false
}

Test-Case: output
Description: Test type-cast-expr as list-constructor expressions.
Labels: list-constructor-expr, type-cast-expr, is-expr, byte, optional-type, tuple-type, singleton-type

function init() {
    byte? b = 221;

    io:println([<byte>21, <byte>b] is [byte, byte]); // @output true
    io:println([<byte>21, <byte>b] is [21, 221?]); // @output false
}

Test-Case: output
Description: Test typeof-expr as list-constructor expressions.
Labels: list-constructor-expr, typeof-expr, is-expr, string, typedesc-type, tuple-type

function init() {
    io:println([typeof 11, typeof "foo"] is [typedesc, typedesc]); // @output true
}

Test-Case: output
Description: Test unary-expr as list-constructor expressions.
Labels: list-constructor-expr, is-expr, unary-complement, unary-minus, unary-plus, unary-not, boolean, singleton-type,
        tuple-type

function init() {
    io:println([+11, -2, !true, ~0] is [int, int, boolean, int]); // @output true
    io:println([+11, -2, !true, ~0] is [11, -2, false, -1]); // @output false
}

Test-Case: output
Description: Test multiplicative-expr as list-constructor expressions.
Labels: list-constructor-expr, is-expr, multiplicative-expr, byte, tuple-type

function init() {
    io:println([3 * 2, 4 / 2, 5 % 2] is [int, int, int]); // @output true
    io:println([3 * 2, 4 / 2, 5 % 2] is [byte, byte, byte]); // @output false
}

Test-Case: output
Description: Test additive-expr as list-constructor expressions.
Labels: list-constructor-expr, is-expr, additive-expr, byte, tuple-type

function init() {
    io:println([1 + 7, 6 - 3] is [int, int]); // @output true
    io:println([1 + 7, 6 - 3] is [byte, byte]); // @output false
}

Test-Case: output
Description: Test shift-expr as list-constructor expressions.
Labels: list-constructor-expr, is-expr, shift-expr, tuple-type, singleton-type, DecimalNumber, unary-minus

function init() {
    io:println([1 << 2, -64 >> 2, 256 >>> 2] is [int, int, int]); // @output true
    io:println([1 << 2, -64 >> 2, 256 >>> 2] is [4, -16, 64]); // @output false
}

Test-Case: output
Description: Test range-expr as list-constructor expressions.
Labels: list-constructor-expr, is-expr, range-expr, record-type, object-type, array-type, isolated-method

function init() {
    io:println([0 ... 2, 1 ..< 3] is object {
        public isolated function iterator() returns object {
            public isolated function next() returns record {|int value;|}?;
        };
    }[]); // @output true
}

Test-Case: output
Description: Test relational-expr as list-constructor expressions.
Labels: list-constructor-expr, is-expr, relational-expr, boolean, singleton-type, tuple-type

function init() {
    io:println([11 <= 11, 2 < 3, 3 > 5, 7 >= 4] is [boolean, boolean, boolean, boolean]); // @output true
    io:println([11 <= 11, 2 < 3, 3 > 5, 7 >= 4] is [true, true, false, true]); // @output false
}

Test-Case: output
Description: Test is-expr as list-constructor expressions.
Labels: list-constructor-expr, is-expr, boolean, singleton-type, tuple-type, byte

function init() {
    io:println([3 is byte, 3 is 3] is [boolean, boolean]); // @output true
    io:println([3 is byte, 3 is 3] is [true, true]); // @output false
}

Test-Case: output
Description: Test equality-expr as list-constructor expressions.
Labels: list-constructor-expr, is-expr, equality, boolean, singleton-type, tuple-type

function init() {
    io:println([3 == 3, 4 != 4, 6 === 6, 1 !== 1] is [boolean, boolean, boolean, boolean]); // @output true
    io:println([3 == 3, 4 != 4, 6 === 6, 1 !== 1] is [true, false, true, false]); // @output false
}

Test-Case: output
Description: Test binary-bitwise-expr as list-constructor expressions.
Labels: list-constructor-expr, is-expr, binary-bitwise-expr, singleton-type, tuple-type

function init() {
    io:println([3 & 0, 4 | 0, 2 ^ 0] is [int, int, int]); // @output true
    io:println([3 & 0, 4 | 0, 2 ^ 0] is [0, 4, 2]); // @output false
}

Test-Case: output
Description: Test logical-expr as list-constructor expressions.
Labels: list-constructor-expr, is-expr, logical-expr, boolean, singleton-type, tuple-type

function init() {
    io:println([true && false, true || false] is [boolean, boolean]); // @output true
    io:println([true && false, true || false] is [false, true]); // @output false
}

Test-Case: output
Description: Test conditional-expr as list-constructor expressions.
Labels: list-constructor-expr, is-expr, ternary-conditional-expr, binary-conditional-expr, optional-type, singleton-type,
        tuple-type

function init() {
    int? num = 5;
    io:println([false ? 3 : 4, num ?: 0] is [int, int]); // @output true
    io:println([false ? 3 : 4, num ?: 0] is [4, 5]); // @output false
}

Test-Case: output
Description: Test checking-expr as list-constructor expressions.
Labels: list-constructor-expr, is-expr, union-type, error-type, check, checkpanic, checking-expr, tuple-type,
        singleton-type

function init() returns error? {
    int|error n = 7;
    io:println([check n, checkpanic n] is [int, int]); // @output true
    io:println([check n, checkpanic n] is [7, 7]); // @output false
}

Test-Case: output
Description: Test trap-expr as list-constructor expressions.
Labels: list-constructor-expr, is-expr, trap-expr, error-constructor-expr, union-type, tuple-type, error-type

function init() {
    io:println([trap 23, trap error("Oops!")] is [(int|error), error]); // @output true
    io:println([trap 23, trap error("Oops!")] is [int, error]); // @output false
}

Test-Case: output
Description: Test query-expr as list-constructor expressions.
Labels: list-constructor-expr, is-expr, query-expr, multiplicative-expr, array-type, singleton-type, tuple-type

function init() {
    io:println([
        from int i in [1, 2, 3]
        select i * 2,
        from int i in [1, 2, 3]
        where i % 2 != 0
        select i
    ] is [int[], int[]]); // @output true

    io:println([
        from int i in [1, 2, 3]
        select i * 2,
        from int i in [1, 2, 3]
        where i % 2 != 0
        select i
    ] is [[2, 4, 6], [1, 3]]); // @output false
}

Test-Case: output
Description: Test transactional-expr as list-constructor expressions.
Fail-Issue: ballerina-platform/ballerina-lang#33087
Labels: list-constructor-expr, is-expr, transactional-expr, string, boolean, singleton-type, tuple-type

function init() {
    io:println(["transaction1", "transaction_description_1", transactional] is [string, string, boolean]); // @output true
    io:println(["transaction1", "transaction_description_1", transactional] is ["transaction1", "transaction_description_1", false]); // @output false
}

Test-Case: output
Description: Test braced-expr as list-constructor expressions.
Labels: list-constructor-expr, is-expr, string, unary-plus, unary-minus, HexIntLiteral, additive-expr, singleton-type,
        tuple-type

function init() {
    io:println([("String"), (+1), (-0x34), (true), (1 + 5)] is [string, int, int, boolean, int]); // @output true
    io:println([("String"), (+1), (-0x34), (true), (1 + 5)] is ["String", 1, -52, true, 6]); // @output false
}
