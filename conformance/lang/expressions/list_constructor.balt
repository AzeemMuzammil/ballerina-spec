Test-Case: output
Description: Test 1 for list-constructor-expr occurring within a const-expr will construct a structural value
             that has its read-only bit on.
Fail-Issue: ballerina-platform/ballerina-lang#13944
Labels: module-const-decl, list-constructor-expr, is-expr, array-type, readonly-type, string

const string[] strArr = [];
const int[] intArr = [1, 2, 3, 4];

function init() {
    io:println(strArr is readonly); // @output true
    io:println(intArr is readonly); // @output true
}

Test-Case: output
Description: Test 2 for list-constructor-expr occurring within a const-expr will construct a structural value
             that has its read-only bit on.
Fail-Issue: ballerina-platform/ballerina-lang#13944
Labels: module-const-decl, list-constructor-expr, is-expr, tuple-type, readonly-type, string, boolean

const [int, string, boolean] tuple1 = [11, "foo", true];
const [int, [boolean, string], boolean] tuple2 = [11, [true, "foo"], true];

function init() {
    io:println(tuple1 is readonly); // @output true
    io:println(tuple2 is readonly); // @output true
}

Test-Case: output
Description: Test 3 for list-constructor-expr occurring within a const-expr will construct a structural value
             that has its read-only bit on.
Fail-Issue: ballerina-platform/ballerina-lang#13944
Labels: module-const-decl, list-constructor-expr, mapping-constructor-expr, member-access-expr, is-expr, array-type,
        map-type, readonly-type

const map<int[]> keyValues = {even: [2, 4, 6], odd: [1, 3, 5]};

function init() {
    io:println(keyValues["odd"] is readonly); // @output true
    io:println(keyValues["even"] is readonly); // @output true
}

Test-Case: output
Description: Test inherent type of the created list when the applicable contextually expected type
             is a list-type-descriptor of any.
Labels: list-constructor-expr, typeof-expr, any, union-type, array-type, tuple-type

function init() {
    any a1 = [];
    io:println(a1 is (any|error)[]); // @output true
    io:println(a1 is any[]); // @output false
    // io:println(a1 is []); // @output false TODO

    any a2 = [1, 2, 3];
    io:println(a2 is (any|error)[]); // @output true
    io:println(a2 is any[]); // @output false
    io:println(a2 is [1, 2, 3]); // @output false

    any a3 = [1, "foo", false];
    io:println(a3 is (any|error)[]); // @output true
    io:println(a3 is any[]); // @output false
    io:println(a3 is [1, "foo", false]); // @output false

    any[] a4 = [1, 2, 3];
    io:println(a4 is (any|error)[]); // @output true
    io:println(a4 is any[]); // @output false
    io:println(a4 is [1, 2, 3]); // @output false

    any|any[] a5 = [1, 2, 3];  // TODO: move to new one with int[]|byte[]
    io:println(a5 is (any|error)[]); // @output true
    io:println(a5 is any[]); // @output false
    io:println(a5 is [1, 2, 3]); // @output false

    [any, any, any] t1 = [13, 25, "foo"];
    io:println(t1 is [any, any, any]); // @output true
    io:println(t1 is [13, 25, "foo"]); // @output false

    [any, any...] t2 = [11, 27, "foo", "bar"];
    io:println(t2 is [any, any...]); // @output true
    io:println(t2 is [any, any, any, any]); // @output false
    io:println(t2 is [13, 25, "foo"]); // @output false
}

Test-Case: output
Description: Test inherent type of the created list when the applicable contextually expected type
             is a list-type-descriptor of anydata.
Labels: list-constructor-expr, typeof-expr, anydata, union-type, array-type, tuple-type

function init() {
    anydata a1 = [];
    io:println(a1 is anydata[]); // @output true
    // io:println(a1 is []); // @output false TODO

    anydata a2 = [1, 2, 3];
    io:println(a2 is anydata[]); // @output true
    io:println(a2 is [1, 2, 3]); // @output false

    anydata a3 = [1, "foo", false];
    io:println(a3 is anydata[]); // @output true
    io:println(a3 is [1, "foo", false]); // @output false

    anydata[] a4 = [1, 2, 3];
    io:println(a4 is anydata[]); // @output true
    io:println(a4 is [1, 2, 3]); // @output false

    anydata|anydata[] a5 = [1, 2, 3];
    io:println(a5 is anydata[]); // @output true
    io:println(a5 is [1, 2, 3]); // @output false

    [anydata, anydata, anydata] t1 = [13, 25, "foo"];
    io:println(t1 is [anydata, anydata, anydata]); // @output true
    io:println(t1 is [13, 25, "foo"]); // @output false

    [anydata, anydata...] t2 = [11, 27, "foo", "bar"];
    io:println(t2 is [anydata, anydata...]); // @output true
    io:println(t2 is [anydata, anydata, anydata, anydata]); // @output false
    io:println(t2 is [11, 27, "foo", "bar"]); // @output false
}

Test-Case: output
Description: Test inherent type of the created list when the applicable contextually expected type
             is a list-type-descriptor of json.
Labels: list-constructor-expr, typeof-expr, union-type, array-type, tuple-type, json

function init() {
    json a1 = [];
    io:println(a1 is json[]); // @output true
    // io:println(a1 is []); // @output false

    json a2 = [true, 2, "foo"];
    io:println(a2 is json[]); // @output true
    io:println(a2 is [true, 2, "foo"]); // @output false

    json[] a3 = [true, 2, "foo"];
    io:println(a3 is json[]); // @output true
    io:println(a3 is [true, 2, "foo"]); // @output false

    json|json[] a4 = [true, 2, "foo"];
    io:println(a4 is json[]); // @output true
    io:println(a4 is [true, 2, "foo"]); // @output false

    [json, json, json] t1 = [true, 2, "foo"];
    io:println(t1 is [json, json, json]); // @output true
    io:println(t1 is [true, 2, "foo"]); // @output false

    [json, json...] t2 = [true, 2, "foo"];
    io:println(t2 is [json, json...]); // @output true
    io:println(t2 is [json, json, json]); // @output false
    io:println(t2 is [true, 2, "foo"]); // @output false
}

Test-Case: output
Description: Test 1 for inherent type of the created list when the applicable contextually expected type
             is a list-type-descriptor with different types.
Labels: list-constructor-expr, typeof-expr, array-type, tuple-type, byte, float, decimal, string, boolean

function init() {
    int[] a1 = [];
    io:println(a1 is int[]); // @output true
    // io:println(a1 is []); // @output false TODO

    int[] a2 = [1, 2, 3];
    io:println(a2 is int[]); // @output true
    io:println(a2 is [1, 2, 3]); // @output false

    byte[] a3 = [17, 212, 33];
    io:println(a3 is byte[]); // @output true
    io:println(a3 is byte[3]); // @output false
    io:println(a3 is [17, 212, 33]); // @output false

    byte[3] a4 = [17, 212, 33];
    io:println(a4 is byte[3]); // @output true
    io:println(a4 is [17, 212, 33]); // @output false

    float[] a5 = [1, 2.0, 25e174, 0.3f];
    io:println(a5 is float[]); // @output true
    io:println(a5 is float[4]); // @output false

    decimal[] a6 = [9d, 21, 7e-56, 2.3];
    io:println(a6 is decimal[]); // @output true
    io:println(a6 is decimal[4]); // @output false

    boolean[*] a7 = [true, true, false];
    io:println(a7 is boolean[3]); // @output true
    io:println(a7 is [true, true, false]); // @output false

    int[][] a8 = [[0, 2, 3], [8, 1, 2], [7, 1, 1]];
    io:println(a8 is int[][]); // @output true
    io:println(a8 is int[3][3]); // @output false
    io:println(a8 is [[0, 2, 3], [8, 1, 2], [7, 1, 1]]); // @output false

    [int, string][] a9 = [[1, "foo"], [2, "bar"], [3, "baz"]];
    io:println(a9 is [int, string][]); // @output true
    io:println(a9 is [int, string][3]); // @output false
    io:println(a9 is [[1, "foo"], [2, "bar"], [3, "baz"]]); // @output false
}

Test-Case: output
Description: Test 2 for inherent type of the created list when the applicable contextually expected type
             is a list-type-descriptor with different types.
Labels: list-constructor-expr, typeof-expr, array-type, tuple-type, byte, string, boolean

function init() {
    [int, int, int] t1 = [];
    io:println(t1 is [int, int, int]); // @output true
    // io:println(t1 is []); // @output false TODO

    [int...] t2 = [];
    io:println(t2 is [int...]); // @output true
    // io:println(t2 is []); // @output false TODO

    [int, int, int] t3 = [1, 2, 3];
    io:println(t3 is [int, int, int]); // @output true
    io:println(t3 is [1, 2, 3]); // @output false

    [int...] t4 = [1, 2, 3];
    io:println(t4 is [int...]); // @output true
    io:println(t4 is [int, int, int]); // @output false
    io:println(t4 is [1, 2, 3]); // @output false

    [byte, byte, byte] t5 = [17, 212, 33];
    io:println(t5 is [byte, byte, byte]); // @output true
    io:println(t5 is [17, 212, 33]); // @output false

    [byte, byte...] t6 = [17, 212, 33];
    io:println(t6 is [byte, byte...]); // @output true
    io:println(t6 is [byte, byte, byte]); // @output false
    io:println(t6 is [17, 212, 33]); // @output false

    [int, int, string] t7 = [1, 2, "foo"];
    io:println(t7 is [int, int, string]); // @output true
    io:println(t7 is [1, 2, "foo"]); // @output false

    [int, [boolean, string], boolean] t8 = [11, [true, "foo"], true];
    io:println(t8 is [int, [boolean, string], boolean]); // @output true
    io:println(t8 is [11, [true, "foo"], true]); // @output false

    [int, string...] t9 = [12, "foo", "bar", "baz"];
    io:println(t9 is [int, string...]); // @output true
    io:println(t9 is [int, string, string, string]); // @output false
    io:println(t9 is [12, "foo", "bar", "baz"]); // @output false

    [int, string[2], boolean] t10 = [1, ["foo", "bar"], true];
    io:println(t10 is [int, string[2], boolean]); // @output true
    io:println(t10 is [1, ["foo", "bar"], true]); // @output false

    [int, [int, string...], int] t11 = [12, [2, "bar", "qux", "quux"], 21];
    io:println(t11 is [int, [int, string...], int]); // @output true
    io:println(t11 is [int, [int, string, string, string], int]); // @output false
    io:println(t11 is [12, [2, "bar", "qux", "quux"], 21]); // @output false
}

Test-Case: output
Description: Test inherent type of the created list when the applicable contextually expected type
             is a list-type-descriptor with readonly.
Labels: list-constructor-expr, typeof-expr, array-type, tuple-type, readonly-type, intersection-type, string

function init() {
    readonly & int[] a1 = [1, 2, 3];
    io:println(a1 is [1, 2, 3]); // @output true
    io:println(a1 is readonly); // @output true

    readonly & [int, string, int] t1 = [33, "foo", 17];
    io:println(t1 is [33, "foo", 17]); // @output true
    io:println(t1 is readonly); // @output true
}

Test-Case: output
Description: Test inherent type of the created list when the applicable contextually expected type
             is a list-type-descriptor with optional types.
Labels: list-constructor-expr, typeof-expr, array-type, tuple-type, optional-type, union-type, string, boolean

function init() {
    int?[] a1 = [1, 2, 3];
    io:println(a1 is int?[]); // @output true
    io:println(a1 is int[]); // @output false

    int?[] a2 = [1, (), 3];
    io:println(a2 is int?[]); // @output true
    io:println(a2 is int[]); // @output false

    int[]? a3 = [1, 2, 3];
    io:println(a3 is int[]); // @output true
    io:println(a3 is [1, 2, 3]); // @output false

    int?[]? a4 = [(), (), ()];
    io:println(a4 is int?[]); // @output true
    io:println(a4 is ()[]); // @output false

    (int?|boolean?|string?)[] a5 = [43, false, "foo"];
    io:println(a5 is (int|boolean|string)?[]); // @output true
    io:println(a5 is (int|boolean|string)[]); // @output false
    io:println(a5 is ()[]); // @output false
    io:println(a5 is [43, false, "foo"]); // @output false

    [int?, boolean?, string?] t1 = [11, false, "foo"];
    io:println(t1 is [int?, boolean?, string?]); // @output true
    io:println(t1 is [int, boolean, string]); // @output false

    [int?, boolean?, string?] t2 = [(), (), ()];
    io:println(t2 is [int?, boolean?, string?]); // @output true
    io:println(t2 is [(), (), ()]); // @output false

    [int?, boolean?, string?]? t3 = [11, false, "foo"];
    io:println(t3 is [int?, boolean?, string?]); // @output true
    io:println(t3 is [int, boolean, string]); // @output false
    io:println(t3 is [11, false, "foo"]); // @output false

    [int?|boolean?, boolean?, string|int?] t4 = [true, false, "foo"];
    io:println(t4 is [(int|boolean)?, boolean?, (string|int)?]); // @output true
    io:println(t4 is [int|boolean, boolean, string|int]); // @output false
    io:println(t4 is [true, false, "foo"]); // @output false

    [int?, [boolean?, string?|boolean], boolean?] t5 = [11, [true, ()], true];
    io:println(t5 is [int?, [boolean?, (string|boolean)?], boolean?]); // @output true
    io:println(t5 is [int, [boolean, (string|boolean)?], boolean]); // @output false
    io:println(t5 is [11, [true, ()], true]); // @output false
}

Test-Case: output
Description: Test 1 for inherent type of the created list when the applicable contextually expected type
             is a list-type-descriptor of unions.
Labels: list-constructor-expr, typeof-expr, array-type, tuple-type, union-type, string, decimal, boolean, byte

function init() {
    (int|string|decimal|boolean)[] a1 = [2.0, "foo", false, true];
    io:println(a1 is (int|string|decimal|boolean)[]); // @output true
    io:println(a1 is (string|decimal|boolean)[]); // @output false

    (int|byte)[] a2 = [1, 2, 3];
    io:println(a2 is (int|byte)[]); // @output true
    io:println(a2 is byte[]); // @output false
    io:println(a2 is [1, 2, 3]); // @output false

    [int|string|decimal|boolean, string, boolean|int] t1 = [2.0, "foo", false];
    io:println(t1 is [(int|string|decimal|boolean), string, (boolean|int)]); // @output true
    io:println(t1 is [decimal, string, boolean]); // @output false

    [int|string, boolean|string...] t2 = [23, "foo", false, "bar", true];
    io:println(t2 is [(int|string), (boolean|string)...]); // @output true
    io:println(t2 is [int, string, boolean, string, boolean]); // @output false
    io:println(t2 is [23, "foo", false, "bar", true]); // @output false

    [int, (int|byte)[]] t3 = [17, [23, 700]];
    io:println(t3 is [int, (int|byte)[]]); // @output true
    io:println(t3 is [int, int[]]); // @output false
    io:println(t3 is [17, [23, 700]]); // @output false

    [int, (int|byte)[]...] t4 = [17, [23, 700]];
    io:println(t4 is [int, (int|byte)[]...]); // @output true
    io:println(t4 is [int, (int|byte)[]]); // @output false
    io:println(t4 is [17, [23, 700]]); // @output false
}

Test-Case: output
Description: Test 2 for inherent type of the created list when the applicable contextually expected type
             is a list-type-descriptor of unions.
Fail-Issue: ballerina-platform/ballerina-lang#33143
Labels: list-constructor-expr, typeof-expr, array-type, tuple-type, union-type, string, decimal, boolean, byte

function init() {
    [(int|byte)[], int] t1 = [[23, 700], 17];
    io:println(t1 is [(int|byte)[], int]); // @output true
    io:println(t1 is [[byte, int], int]); // @output false
    io:println(t1 is [[23, 700], 17]); // @output false

    [((int|byte)[])...] t2 = [[17], [23, 700]];
    io:println(t2 is [((int|byte)[])...]); // @output true
    io:println(t2 is [((int|byte)[]), ((int|byte)[])]); // @output false
    io:println(t2 is [[17], [23, 700]]); // @output false

    [(int|byte)[], (boolean|string)[]...] t3 = [[23, 700, 252, 0], ["foo", false, "bar", true], [true], ["qux", "quux"]];
    io:println(t3 is [(int|byte)[], (boolean|string)[]...]); // @output true
    io:println(t3 is [(int|byte)[], (boolean|string)[], (boolean|string)[], (boolean|string)[]]); // @output false
    io:println(t3 is [[23, 700, 252, 0], ["foo", false, "bar", true], [true], ["qux", "quux"]]); // @output false

    [(int|byte)[]...] t4 = [[17], [23, 700]];
    io:println(t4 is [(int|byte)[]...]); // @output true
    io:println(t4 is [(int|byte)[], (int|byte)[]]); // @output false
    io:println(t4 is [[17], [23, 700]]); // @output false
}

Test-Case: output
Description: Test inherent type of the created list when the applicable contextually expected type
             is a list-type-descriptor of user-defined type.
Labels: module-type-defn, list-constructor-expr, typeof-expr, array-type, tuple-type, union-type, singleton-type,
        boolean

type Ints 0|1|2|3;

function init() {
    Ints[] a1 = [1, 3, 0];
    io:println(a1 is Ints[]); // @output true
    io:println(a1 is (0|1|3)[]); // @output false
    io:println(a1 is [1, 3, 0]); // @output false

    [Ints, Ints, boolean] t1 = [2, 0, true];
    io:println(t1 is [Ints, Ints, boolean]); // @output true
    io:println(t1 is [0|2, 0|2, boolean]); // @output false
    io:println(t1 is [2, 0, true]); // @output false
}

Test-Case: output
Description: Test inherent type of the created list when the applicable contextually expected type
             is a list-type-descriptor of record or map.
Labels: module-type-defn, list-constructor-expr, mapping-constructor-expr, typeof-expr, array-type, tuple-type,
        map-type, string

type Student record {|
    int id;
    string name;
    int age;
|};

function init() {
    Student[] a1 = [{id: 111, name: "Mike", age: 15}, {id: 99, name: "Emma", age: 17}];
    io:println(a1 is Student[]); // @output true
    io:println(a1 is Student[2]); // @output false

    map<string>[] a2 = [{firstName: "Joey", lastName: "Tribbiani"}, {firstName: "Monica", lastName: "Geller"}];
    io:println(a2 is map<string>[]); // @output true
    io:println(a2 is map<string>[2]); // @output false
    io:println(a2 is map<"Joey"|"Tribbiani"|"Monica"|"Geller">[]); // @output false

    [Student...] t1 = [{id: 111, name: "Mike", age: 15}, {id: 99, name: "Emma", age: 17}];
    io:println(t1 is [Student...]); // @output true
    io:println(t1 is [Student, Student]); // @output false

    [map<string>, map<int>] t2 = [{firstName: "Ross", lastName: "Geller"}, {circles: 12, rectangles: 7}];
    io:println(t2 is [map<string>, map<int>]); // @output true
    io:println(t2 is [map<"Ross"|"Geller">, map<12|7>]); // @output false
}

Test-Case: output
Description: Test inherent type of the created list when the applicable contextually expected type
             is a list-type-descriptor, where the contextually expected type is a union.
Labels: list-constructor-expr, typeof-expr, array-type, tuple-type, union-type, byte, decimal

function init() {
    int[]|int|byte|decimal a1 = [1, 2, 3];
    io:println(a1 is int[]); // @output true
    io:println(a1 is (1|2|3)[]); // @output false
    io:println(a1 is [1, 2, 3]); // @output false

    [int, string, int]|int|byte|decimal t1 = [34, "foo", 13];
    io:println(t1 is [int, string, int]); // @output true
    io:println(t1 is [byte, string, byte]); // @output false
    io:println(t1 is [34, "foo", 13]); // @output false
}

Test-Case: output
Description: Test when the applicable contextually expected type is a union type descriptor,
             any members of the union that do not contain list shapes of length N will be ignored,
             where N is the number of expressions in the expr-list.
Labels: list-constructor-expr, typeof-expr, array-type, tuple-type, union-type, byte

function init() {
    int[2]|int[3]|byte[] a1 = [1, 2, 3, 4];
    io:println(a1 is byte[]); // @output true
    io:println(a1 is byte[4]); // @output false
    io:println(a1 is (1|2|3|4)[]); // @output false

    int[2]|int[3]|int[*] a2 = [1, 2, 3, 4];
    io:println(a2 is int[4]); // @output true
    io:println(a2 is byte[4]); // @output false

    int[2]|int[3]|int[]|int|byte a3 = [1, 2, 3, 4];
    io:println(a3 is int[]); // @output true
    io:println(a3 is int[4]); // @output false
    io:println(a3 is byte[]); // @output false

    [int]|[int, int]|[int, int, int] t1 = [1, 2, 3];
    io:println(t1 is [int, int, int]); // @output true
    io:println(t1 is [byte, byte, byte]); // @output false

    [int]|[int, int]|int|byte t2 = [1, 2];
    io:println(t2 is [int, int]); // @output true
    io:println(t2 is [byte, byte]); // @output false

    [int...]|int|byte t3 = [1, 2];
    io:println(t3 is [int...]); // @output true
    io:println(t3 is int[2]); // @output false
    io:println(t3 is [byte...]); // @output false
}

Test-Case: error // TODO: could be error or output. Check with James.
Description: Test 1 for the compile-time error when the applicable contextually expected type does not leave
             a single list type descriptor.
Fail-Issue: ballerina-platform/ballerina-lang#33129
Labels: list-constructor-expr, array-type, tuple-type, union-type

function init() {
    int[4]|int[3] _ = [1, 2, 3]; // @error ambiguous type '(int[4]|int[3])'
    [int, int, int]|[int] _ = [1]; // @error ambiguous type '([int,int,int]|[int])'

    int[2]|[int, int, int] _ = [1, 2]; // @error ambiguous type '(int[2]|[int,int,int])'
    int[3]|[int, int] _ = [1, 2]; // @error ambiguous type '(int[3]|[int,int])'

    ([int]|[int, int])[] _ = [[1], [1, 2]]; // @error ambiguous type '([int]|[int,int])'
}

Test-Case: error
Description: Test 2 for the compile-time error when the applicable contextually expected type does not leave
             a single list type descriptor.
Labels: list-constructor-expr, array-type, tuple-type, union-type, byte, string, boolean

function init() {
    int[]|int[3] _ = [1, 2]; // @error ambiguous type '(int[]|int[3])'
    int[]|int[3] _ = [1, 2, 3]; // @error ambiguous type '(int[]|int[3])'
    int[]|byte[] _ = [1, 2, 3]; // @error ambiguous type '(int[]|byte[])'

    int[2]|int[3] _ = [12]; // @error ambiguous type '(int[2]|int[3])'

    [int...]|[int, int, int] _ = [1, 2]; // @error ambiguous type '([int...]|[int,int,int])'
    [int...]|[int, int, int] _ = [1, 2, 3]; // @error ambiguous type '([int...]|[int,int,int])'
    [int...]|[byte...] _ = [1, 2, 3]; // @error ambiguous type '([int...]|[byte...])'

    [int, int]|[int, int, int] _ = [1]; // @error ambiguous type '([int,int]|[int,int,int])'

    int[]|[int, int, int] _ = [1, 2]; // @error ambiguous type '(int[]|[int,int,int])'
    int[]|[int, int, int] _ = [1, 2, 3]; // @error ambiguous type '(int[]|[int,int,int])'
    int[]|[byte...] _ = [1, 2, 3]; // @error ambiguous type '(int[]|[byte...])'

    int[2]|[int, int, int] _ = [1]; // @error ambiguous type '(int[2]|[int,int,int])'

    int[]|int[3]|boolean[] _ = [1, 2, 3]; // @error ambiguous type '(int[]|int[3]|boolean[])'
    int|string|boolean _ = [1, 2, 3]; // @error incompatible types: expected '(int|string|boolean)', found '[int,int,int]'
}

Test-Case: error
Description: Test 3 for the compile-time error when the applicable contextually expected type does not leave
             a single list type descriptor.
Fail-Issue: ballerina-platform/ballerina-lang#33056
Labels: list-constructor-expr, array-type, tuple-type, union-type, byte, string, boolean

function init() {
    string[]|int[]|boolean[] _ = [1, 2, 3]; // @error // TODO: add error descriptions
    string[]|int[] _ = [1, 2, 3]; // @error

    [int, int, int]|[string...] _ = [1, 2, 3]; // @error
    [int, int, int]|[string...]|int|boolean _ = [1, 2, 3]; // @error

    [int, int, int]|boolean[] _ = [1, 2, 3]; // @error
    int[]|[boolean] _ = [1, 2, 3]; // @error
}

Test-Case: output
Description: Test when there is no contextually expected type, then the inherent type is a a tuple-type-descriptor
             with a member-type-descriptor for each expression in the expr-list,
             where the type of each member-type-descriptor will be the broad type of the corresponding expression
             in the expr-list.
Labels: list-constructor-expr, typeof-expr, var, boolean-literal

function init() {
    var a1 = [1, 2, 3];
    io:println(a1 is [int, int, int]); // @output true
    io:println(a1 is [byte, byte, byte]); // @output false // add few tests for update references and test, tests for negative assigments TODO

    var a2 = [1, "foo", "bar", 3];
    io:println(a2 is [int, string, string, int]); // @output true
    io:println(a2 is [byte, "foo", "bar", byte]); // @output false

    var a3 = [1, ["foo", [true, 23]], [true, false, true]];
    io:println(a3 is [int, [string, [boolean, int]], [boolean, boolean, boolean]]); // @output true
    io:println(a3 is [1, ["foo", [true, 23]], [true, false, true]]); // @output false

    io:println([1, 2, 3] is [int, int, int]); // @output true
    io:println([1, 2, 3] is [1, 2, 3]); // @output false

    io:println([1, "foo", "bar", 3] is [int, string, string, int]); // @output true
    io:println([1, "foo", "bar", 3] is [1, "foo", "bar", 3]); // @output false

    io:println([1, ["foo", [true, 23]], [true, false, true]] is [int, [string, [boolean, int]], [boolean, boolean, boolean]]); // @output true
    io:println([1, ["foo", [true, 23]], [true, false, true]] is [1, ["foo", [true, 23]], [true, false, true]]); // @output false
}

Test-Case: output
Description: Test 1 when there is a contextually expected type, then the type that the inherent type
             requires for each list member provides the contextually expected type for the expression for the member.
Labels: list-constructor-expr, typeof-expr, member-access-expr, array-type, tuple-type, byte, string

function init() {
    int[] a1 = [1, 2, 3];
    io:println(a1[0] is int); // @output true
    io:println(a1[0] is 1); // @output false

    io:println(a1[1] is int); // @output true
    io:println(a1[1] is byte); // @output false

    io:println(a1[2] is int); // @output true
    io:println(a1[2] is byte); // @output false

    [int, byte, string] a2 = [1, 2, "foo"];

    io:println(a2[0] is int); // @output true
    io:println(a2[0] is byte); // @output false

    io:println(a2[1] is byte); // @output true
    io:println(a2[1] is 2); // @output false

    io:println(a2[2] is string); // @output true
    io:println(a2[2] is "foo"); // @output false

    [int, byte...] a3 = [1, 2, 3];
    io:println(a3[0] is int); // @output true
    io:println(a3[0] is byte); // @output false

    io:println(a3[1] is byte); // @output true
    io:println(a3[1] is 1|2|3); // @output false

    io:println(a3[2] is byte); // @output true
    io:println(a3[2] is 3); // @output false
}

Test-Case: output
Description: Test 2 when there is a contextually expected type, then the type that the inherent type
             requires for each list member provides the contextually expected type for the expression for the member.
Fail-Issue: ballerina-platform/ballerina-lang# // TODO: verify and create an issue
Labels: list-constructor-expr, typeof-expr, member-access-expr, array-type, tuple-type, union-type, optional-type, string
function init() {
    int?[] a1 = [1, 2, 3];

    io:println(a1[0] is int?); // @output true
    io:println(a1[0] is int); // @output false

    io:println(a1[1] is int?); // @output true
    io:println(a1[1] is int); // @output false

    io:println(a1[2] is int?); // @output true
    io:println(a1[2] is int); // @output false

    (int|string)[] a2 = [1, 2, 3];

    io:println(a2[0] is int|string); // @output true
    io:println(a2[0] is int); // @output false

    io:println(a2[1] is int|string); // @output true
    io:println(a2[1] is int); // @output false

    io:println(a2[2] is int|string); // @output true
    io:println(a2[2] is int); // @output false

    [int, string?...] a3 = [1, "foo", "bar"];

    io:println(a3[0] is int); // @output true
    io:println(a3[0] is 1); // @output false

    io:println(a3[1] is string?); // @output true
    io:println(a3[1] is string); // @output false

    io:println(a3[2] is string?); // @output true
    io:println(a3[2] is string); // @output false

    [int, string|int, string?|int] a4 = [1, "foo", "bar"];

    io:println(a4[0] is int); // @output true
    io:println(a4[0] is 1); // @output false

    io:println(a4[1] is string|int); // @output true
    io:println(a4[1] is string); // @output false

    io:println(a4[2] is (string|int)?); // @output true
    io:println(a4[2] is string|int); // @output false
}

Test-Case: output
Description: Test few cases for, a member of list being able to fill automatically
             when the FillMember abstract operation succeed on it.
Labels: list-constructor-expr, array-type, tuple-type, string, boolean
// split, array and tuple.
function init() {
    int[5] a1 = [1, 2, 3];
    io:println(a1); // @output [1,2,3,0,0]

    [int, string, int, boolean] t1 = [1, "foo"];
    io:println(t1); // @output 1 foo 0 false
}

Test-Case: error
Description: Test few cases for, a member of list being  unable to fill automatically
             as the FillMember abstract operation fails on it.
Labels: list-constructor-expr, array-type, tuple-type, union-type, boolean, string

function init() {
    (int|string)[4] _ = [1, 2]; // @error invalid usage of list constructor: type '(int|string)[4]' does not have a filler value

    [int,boolean|string] _ = [1]; // @error tuple and expression size does not match
}

Test-Case: output
Description: Test list-constructor-expr in module-var-decl.
Labels: module-init-var-decl, list-constructor-expr, typeof-expr, array-type, tuple-type, union-type, byte, boolean,
        string

int[] a1 = [1, 2, 3];
int[][] a2 = [[0, 2, 3], [8, 1, 2], [7, 1, 1]];

[int, int, int] t1 = [1, 2, 3];
[int...] t2 = [1, 2, 3];

[(int|byte)[], int] t3 = [[23, 700], 17];
[(int|byte)[]...] t4 = [[17], [23, 700]];
[(int|byte)[], (boolean|string)[]...] t5 = [[23, 700, 252, 0], ["foo", false, "bar", true], [true], ["qux", "quux"]];

function init() {
    io:println(a1 is int[]); // @output true
    io:println(a1 is int[3]); // @output false
    io:println(a1 is byte[]); // @output false

    io:println(a2 is int[][]); // @output true
    io:println(a2 is int[3][3]); // @output false
    io:println(a2 is byte[][]); // @output false

    io:println(t1 is [int, int, int]); // @output true
    io:println(t1 is [byte, byte, byte]); // @output false

    io:println(t2 is [int...]); // @output true
    io:println(t2 is [int, int, int]); // @output false
    io:println(t2 is [byte...]); // @output false

    io:println(t3 is [(int|byte)[], int]); // @output true
    io:println(t3 is [(int|byte)[1], int]); // @output false
    io:println(t3 is [int[], int]); // @output false

    io:println(t4 is [(int|byte)[]...]); // @output true
    io:println(t4 is [(int|byte)[], (int|byte)[]]); // @output false
    io:println(t4 is [int[]...]); // @output false

    io:println(t5 is [(int|byte)[], (boolean|string)[]...]); // @output true
    io:println(t5 is [int[], (boolean|string)[]...]); // @output false
    io:println(t5 is [(int|byte)[], (boolean|string)[], (boolean|string)[]]); // @output false
}

Test-Case: output // TODO: add label to rest of test here on.
Description: Test literals as list-constructor expressions.
Labels: list-constructor-expr

function init() {
    var arr = [11, 2.0d, true, base64 `bGlnaHQgd29y`, (), "foo", 0x12, 7e-56, 0X21.5, 3.9];

    io:println(arr is [int, decimal, boolean, byte[], (), string, byte, float, float, float]); // @output true
    io:println(arr is [11, 2.0d, true, byte[], (), "foo", 0x12, 7e-56, 0X21.5, 3.9]); // @output false}

Test-Case: output
Description: Test string-template-expr as list-constructor expressions.
Labels: list-constructor-expr

function init() {
    var arr = [string `Hello ${10 * 3}!!`, "foo", string `\u{61}NT`, "bar"];

    io:println(arr is [string, string, string, string]); // @output true
    io:println(arr is ["Hello 30!!", "foo", "\u{61}NT", "bar"]); // @output false
}

Test-Case: output
Description: Test xml-template-expr as list-constructor expressions.
Labels: list-constructor-expr

function init() {
    var arr = [xml `<name>Mike</name>`, xml `${7 + 3}`, xml `<!-- hello -->`];

    io:println(arr is [xml:Element, xml:Text, xml:Comment]); // @output true
}

Test-Case: output
Description: Test raw-template-expr as list-constructor expressions.
Labels: list-constructor-expr

function init() {
    var arr = [`x + y = ${2 + 3}`, `Count:${1}`, `INSERT INTO Details VALUES (${"Foo"}, ${20})`];

    io:println(arr is [object:RawTemplate, object:RawTemplate, object:RawTemplate]); // @output true
}

Test-Case: output
Description: Test structural-constructor-expr as list-constructor expressions.
Labels: list-constructor-expr

function init() {
    var arr = [
        [23, "foo"],
        table key(id) [
                {id: 1, name: "Frank", age: 54},
                {id: 2, name: "John", age: 47}
            ],
        {a: 1, b: "bar", c: true}
    ];

    io:println(arr is [[int, string], table<record {|readonly int id; string name; int age;|}> key(id), record {|int a; string b; boolean c;|}]); // @output true
    io:println(arr is [[23, "foo"], table<record {|readonly int id; string name; int age;|}> key(id), record {|int a; string b; boolean c;|}]); // @output false
}

Test-Case: output
Description: Test object-constructor-expr as list-constructor expressions.
Labels: list-constructor-expr

function init() {
    io:println([
        object {
            int i;
            function init() {
                self.i = 20;
            }
        },
        object {
            int a;
            string[] b;

            function init() {
                self.a = 21;
                self.b = [];
            }
        },
        object {}
    ] is object {}[]); // @output true
}

Test-Case: output
Description: Test as new-expr list-constructor expressions.
Labels: list-constructor-expr

class Student {
    int i;

    function init() {
        self.i = 0;
    }
}

function init() {
    Student[] arr = [new, new Student()];

    io:println(arr is Student[]); // @output true
}

Test-Case: output
Description: Test variable-reference-expr as list-constructor expressions.
Labels: list-constructor-expr

function init() {
    string name = "Ballerina";
    decimal ver = 2.0;
    string[] arr = ["R", "O", "X"];

    io:println([name, ver, arr] is [string, decimal, string[]]); // @output true
    io:println([name, ver, arr] is ["Ballerina", decimal, string[]]); // @output false
}

Test-Case: output
Description: Test field-access-expr as list-constructor expressions.
Labels: list-constructor-expr

type Employee record {|
    int id;
    string name;
|};

function init() {
    Employee emp = {id: 0, name: "John"};

    io:println([emp.id, emp.name] is [int, string]); // @output true
    io:println([emp.id, emp.name] is [0, "John"]); // @output false
}

Test-Case: output
Description: Test optional-field-access as list-constructor expressions.
Labels: list-constructor-expr

type Employee record {|
    int id;
    string fName;
    string lName?;
|};

function init() {
    Employee emp = {id: 0, fName: "Ross", lName: "Geller"};

    io:println([emp?.id, emp?.fName, emp?.lName] is [int, string, string?]); // @output true
    io:println([emp?.id, emp?.fName, emp?.lName] is [int, string, string]); // @output false
    io:println([emp?.id, emp?.fName, emp?.lName] is [int, "Ross", "Geller"?]); // @output false
}

Test-Case: output
Description: Test annot-access-expr as list-constructor expressions.
Labels: list-constructor-expr

annotation v1 on type;

annotation v2 on type;

@v1
type T1 record {
    string name;
};

T1 t1 = {name: "Ross"};

function init() {
    typedesc<T1> t = typeof t1;

    io:println([t.@v1, t.@v2] is [true?, true?]); // @output true
    io:println([t.@v1, t.@v2] is [true, true]); // @output false
}

Test-Case: output
Description: Test member-access-expr as list-constructor expressions.
Labels: list-constructor-expr

function init() {
    int[] arr = [1, 2, 3, 4, 5];

    io:println(arr[0] is int); // @output true
    io:println(arr[0] is byte); // @output false

    io:println(arr[2] is int); // @output true
    io:println(arr[2] is byte); // @output false

    io:println(arr[4] is int); // @output true
    io:println(arr[4] is byte); // @output false
}

Test-Case: output
Description: Test function-call-expr as list-constructor expressions.
Labels: list-constructor-expr

function init() {
    io:println([isSameNumber(3, 2), isSameNumber(4, 4)] is [boolean, boolean]); // @output true
    io:println([isSameNumber(3, 2), isSameNumber(4, 4)] is [false, true]); // @output false
}

function isSameNumber(int a, int b) returns boolean {
    return a == b;
}

Test-Case: output
Description: Test method-call-expr as list-constructor expressions.
Labels: list-constructor-expr

function init() {
    io:println(["Hello".toString(), "World".toString()] is [string, string]); // @output true
    io:println(["Hello".toString(), "World".toString()] is ["Hello", "World"]); // @output false
}

Test-Case: output
Description: Test error-constructor-expr as list-constructor expressions.
Labels: list-constructor-expr

function init() {
    io:println([error("Oh, NO!"), error("OMG!")] is [error,error]); // @output true
}

Test-Case: output
Description: Test error-constructor-expr as list-constructor expressions.
Labels: list-constructor-expr

type func function () returns int;

function init() {
    func[] arr = [
        function() returns byte {
            return 5;
        },
        () => 10
    ];

    io:println(arr is (function () returns int)[]); // @output true
    io:println(arr is (function () returns byte)[]); // @output false
}

Test-Case: output
Description: Test let-expr as list-constructor expressions.
Labels: list-constructor-expr

function init() {
    io:println([
        let int i = 4
            in i * 2,
        let int x = 3
            in x == 3
    ] is [int, boolean]); // @output true

    io:println([
        let int i = 4
            in i * 2,
        let int x = 3
            in x == 3
    ] is [8, true]); // @output false
}

Test-Case: output
Description: Test type-cast-expr as list-constructor expressions.
Labels: list-constructor-expr

function init() {
    byte? b = 221;

    io:println([<byte>21, <byte>b] is [byte, byte]); // @output true
    io:println([<byte>21, <byte>b] is [21, 221?]); // @output false
}

Test-Case: output
Description: Test typeof-expr as list-constructor expressions.
Labels: list-constructor-expr

function init() {
    io:println([typeof 11, typeof "foo"] is [typedesc, typedesc]); // @output true
}

Test-Case: output
Description: Test unary-expr as list-constructor expressions.
Labels: list-constructor-expr

function init() {
    io:println([+11, -2, !true, ~0] is [int, int, boolean, int]); // @output true
    io:println([+11, -2, !true, ~0] is [11, -2, false, -1]); // @output false
}

Test-Case: output
Description: Test multiplicative-expr as list-constructor expressions.
Labels: list-constructor-expr

function init() {
    io:println([3 * 2, 4 / 2, 5 % 2] is [int, int, int]); // @output true
    io:println([3 * 2, 4 / 2, 5 % 2] is [byte, byte, byte]); // @output false
}

Test-Case: output
Description: Test additive-expr as list-constructor expressions.
Labels: list-constructor-expr

function init() {
    io:println([1 + 7, 6 - 3] is [int, int]); // @output true
    io:println([1 + 7, 6 - 3] is [byte, byte]); // @output false
}

Test-Case: output
Description: Test shift-expr as list-constructor expressions.
Labels: list-constructor-expr

function init() {
    io:println([1 << 2, -64 >> 2, 256 >>> 2] is [int, int, int]); // @output true
    io:println([1 << 2, -64 >> 2, 256 >>> 2] is [4, -16, 64]); // @output false
}

Test-Case: output
Description: Test range-expr as list-constructor expressions.
Labels: list-constructor-expr

function init() {
    io:println([0 ... 2, 1 ..< 3] is object {
        public isolated function iterator() returns object {
            public isolated function next() returns record {|int value;|}?;
        };
    }[]); // @output true
}

Test-Case: output
Description: Test relational-expr as list-constructor expressions.
Labels: list-constructor-expr

function init() {
    io:println([11 <= 11, 2 < 3, 3 > 5, 7 >= 4] is [boolean, boolean, boolean, boolean]); // @output true
    io:println([11 <= 11, 2 < 3, 3 > 5, 7 >= 4] is [true, true, false, true]); // @output false
}

Test-Case: output
Description: Test is-expr as list-constructor expressions.
Labels: list-constructor-expr

function init() {
    io:println([3 is byte, 3 is 3] is [boolean, boolean]); // @output true
    io:println([3 is byte, 3 is 3] is [true, true]); // @output false
}

Test-Case: output
Description: Test equality-expr as list-constructor expressions.
Labels: list-constructor-expr

function init() {
    io:println([3 == 3, 4 != 4, 6 === 6, 1 !== 1] is [boolean, boolean, boolean, boolean]); // @output true
    io:println([3 == 3, 4 != 4, 6 === 6, 1 !== 1] is [true, false, true, false]); // @output false
}

Test-Case: output
Description: Test binary-bitwise-expr as list-constructor expressions.
Labels: list-constructor-expr

function init() {
    io:println([3 & 0, 4 | 0, 2 ^ 0] is [int, int, int]); // @output true
    io:println([3 & 0, 4 | 0, 2 ^ 0] is [0, 4, 2]); // @output false
}

Test-Case: output
Description: Test logical-expr as list-constructor expressions.
Labels: list-constructor-expr

function init() {
    io:println([true && false, true || false] is [boolean, boolean]); // @output true
    io:println([true && false, true || false] is [false, true]); // @output false
}

Test-Case: output
Description: Test conditional-expr as list-constructor expressions.
Labels: list-constructor-expr

function init() {
    int? num = 5;
    io:println([false ? 3 : 4, num ?: 0] is [int, int]); // @output true
    io:println([false ? 3 : 4, num ?: 0] is [4, 5]); // @output false
}

Test-Case: output
Description: Test checking-expr as list-constructor expressions.
Labels: list-constructor-expr

function init() returns error? {
    int|error n = 7;
    io:println([check n, checkpanic n] is [int, int]); // @output true
    io:println([check n, checkpanic n] is [7, 7]); // @output false
}

Test-Case: output
Description: Test trap-expr as list-constructor expressions.
Labels: list-constructor-expr

function init() {
    io:println([trap 23, trap error("Oops!")] is [(int|error), error]); // @output true
    io:println([trap 23, trap error("Oops!")] is [int, error]); // @output false
}

Test-Case: output
Description: Test query-expr as list-constructor expressions.
Fail-Issue: ballerina-platform/ballerina-lang#33085
Labels: list-constructor-expr

function init() {
    io:println([
        from int i in [1, 2, 3]
        select i * 2,
        from int i in [1, 2, 3]
        where i % 2 != 0
        select i
    ] is [int[], int[]]); // @output true

    io:println([
        from int i in [1, 2, 3]
        select i * 2,
        from int i in [1, 2, 3]
        where i % 2 != 0
        select i
    ] is [[2, 4, 6], [1, 3]]); // @output false
}

Test-Case: output
Description: Test transactional-expr as list-constructor expressions.
Fail-Issue: ballerina-platform/ballerina-lang#33087
Labels: list-constructor-expr

function init() {
    io:println(["transaction1", "transaction_description_1", transactional] is [string, string, boolean]); // @output true
    io:println(["transaction1", "transaction_description_1", transactional] is ["transaction1", "transaction_description_1", false]); // @output false
}

Test-Case: output
Description: Test braced-expr as list-constructor expressions.
Labels: list-constructor-expr

function init() {
    io:println([("String"), (+1), (-0x34), (true), (1 + 5)] is [string, int, int, boolean, int]); // @output true
    io:println([("String"), (+1), (-0x34), (true), (1 + 5)] is ["String", 1, -52, true, 6]); // @output false
}
