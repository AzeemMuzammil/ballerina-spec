Test-Case: output
Description: Test whether the static type of key expression is a subtype of int when the static type of the
             container expression is an xml.
Labels: member-access-expr, byte, int, int:Signed8, int:Signed16, int:Signed32, int:Unsigned8,
        int:Unsigned32, xml

function init() {
    xml authors = xml `<name>Sherlock Holmes</name><name>Enid Blyton</name><name>Dan Brown</name><name>Nicholas Sparks</name>`;

    int i0 = 0;
    io:println(authors[i0]); // @output <name>Sherlock Holmes</name>

    int:Signed8 i1 = 1;
    io:println(authors[i1]); // @output <name>Enid Blyton</name>

    int:Signed16 i2 = 2;
    io:println(authors[i2]); // @output <name>Dan Brown</name>

    int:Signed32 i3 = 3;
    io:println(authors[i3]); // @output <name>Nicholas Sparks</name>

    int:Unsigned8 i4 = 0;
    io:println(authors[i4]); // @output <name>Sherlock Holmes</name>

    int:Unsigned16 i5 = 1;
    io:println(authors[i5]); // @output <name>Enid Blyton</name>

    int:Unsigned32 i6 = 2;
    io:println(authors[i6]); // @output <name>Dan Brown</name>

    byte i7 = 3;
    io:println(authors[i7]); // @output <name>Nicholas Sparks</name>

    io:println(authors[0]); // @output <name>Sherlock Holmes</name>
}

Test-Case: output
Description: Test whether the static type of key expression is a subtype of int when the static type of the
             container expression is an xml.
Labels: member-access-expr, byte, int, int:Signed8, int:Signed16, int:Unsigned8, int:Unsigned32, xml

const i8 = 0;

type IntType1 int:Signed8|int:Signed16;

type IntType2 i8|2;

function init() {
    xml authors = xml `<name>Sherlock Holmes</name><name>Enid Blyton</name><name>Dan Brown</name><name>Nicholas Sparks</name>`;

    io:println(authors[i8]); // @output <name>Sherlock Holmes</name>

    IntType1 i9 = 1;
    io:println(authors[i9]); // @output <name>Enid Blyton</name>

    IntType2 i10 = 2;
    io:println(authors[i10]); // @output <name>Dan Brown</name>

    1|3 i11 = 3;
    io:println(authors[i11]); // @output <name>Nicholas Sparks</name>

    int:Unsigned8|int:Unsigned32 i12 = 2;
    io:println(authors[i12]); // @output <name>Dan Brown</name>

    int:Unsigned16|byte i13 = 1;
    io:println(authors[i13]); // @output <name>Enid Blyton</name>
}

Test-Case: output
Description: Test whether the static type of key expression is a subtype of int when the static type of the
             container expression is an xml:Element.
Labels: member-access-expr, byte, int, int:Signed8, int:Signed16, int:Signed32, int:Unsigned8, int:Unsigned32,
        xml:Element

function init() {
    xml:Element author = xml `<name>Sherlock Holmes</name>`;

    int i0 = 0;
    io:println(author[i0]); // @output <name>Sherlock Holmes</name>

    int:Signed8 i1 = 0;
    io:println(author[i1]); // @output <name>Sherlock Holmes</name>

    int:Signed16 i2 = 0;
    io:println(author[i2]); // @output <name>Sherlock Holmes</name>

    int:Signed32 i3 = 0;
    io:println(author[i3]); // @output <name>Sherlock Holmes</name>

    int:Unsigned8 i4 = 0;
    io:println(author[i4]); // @output <name>Sherlock Holmes</name>

    int:Unsigned16 i5 = 0;
    io:println(author[i5]); // @output <name>Sherlock Holmes</name>

    int:Unsigned32 i6 = 0;
    io:println(author[i6]); // @output <name>Sherlock Holmes</name>

    byte i7 = 0;
    io:println(author[i7]); // @output <name>Sherlock Holmes</name>

    io:println(author[0]); // @output <name>Sherlock Holmes</name>
}

Test-Case: output
Description: Test whether the static type of key expression is a subtype of int when the static type of the
             container expression is an xml:Element.
Labels: member-access-expr, byte, int, int:Signed8, int:Signed16, int:Signed32, int:Unsigned8, int:Unsigned32,
        xml:Element

const i8 = 0;

type IntType1 int:Signed8|int:Signed16;

type IntType2 i8|2;

function init() {
    xml:Element author = xml `<name>Sherlock Holmes</name>`;

    io:println(author[i8]); // @output <name>Sherlock Holmes</name>

    IntType1 i9 = 0;
    io:println(author[i9]); // @output <name>Sherlock Holmes</name>

    IntType2 i10 = 0;
    io:println(author[i10]); // @output <name>Sherlock Holmes</name>

    1|0 i11 = 0;
    io:println(author[i11]); // @output <name>Sherlock Holmes</name>

    int:Unsigned8|int:Unsigned32 i12 = 0;
    io:println(author[i12]); // @output <name>Sherlock Holmes</name>

    int:Unsigned16|byte i13 = 0;
    io:println(author[i13]); // @output <name>Sherlock Holmes</name>
}

Test-Case: output
Description: Test whether the static type of key expression is a subtype of int when the static type of the
             container expression is an xml:ProcessingInstruction.
Labels: member-access-expr, byte, int, int:Signed8, int:Signed16, int:Signed32, int:Unsigned8, int:Unsigned32,
        xml:ProcessingInstruction

function init() {
    xml:ProcessingInstruction style = xml `<?xml-stylesheet type="text/xsl" href="style.xsl"?>`;

    int i0 = 0;
    io:println(style[i0]); // @output <?xml-stylesheet type="text/xsl" href="style.xsl"?>

    int:Signed8 i1 = 0;
    io:println(style[i1]); // @output <?xml-stylesheet type="text/xsl" href="style.xsl"?>

    int:Signed16 i2 = 0;
    io:println(style[i2]); // @output <?xml-stylesheet type="text/xsl" href="style.xsl"?>

    int:Signed32 i3 = 0;
    io:println(style[i3]); // @output <?xml-stylesheet type="text/xsl" href="style.xsl"?>

    int:Unsigned8 i4 = 0;
    io:println(style[i4]); // @output <?xml-stylesheet type="text/xsl" href="style.xsl"?>

    int:Unsigned16 i5 = 0;
    io:println(style[i5]); // @output <?xml-stylesheet type="text/xsl" href="style.xsl"?>

    int:Unsigned32 i6 = 0;
    io:println(style[i6]); // @output <?xml-stylesheet type="text/xsl" href="style.xsl"?>

    byte i7 = 0;
    io:println(style[i7]); // @output <?xml-stylesheet type="text/xsl" href="style.xsl"?>

    io:println(style[0]); // @output <?xml-stylesheet type="text/xsl" href="style.xsl"?>
}

Test-Case: output
Description: Test whether the static type of key expression is a subtype of int when the static type of the
             container expression is an xml:ProcessingInstruction.
Labels: member-access-expr, byte, int, int:Signed8, int:Signed16, int:Signed32, int:Unsigned8, int:Unsigned32,
        xml:ProcessingInstruction

const i8 = 0;

type IntType1 int:Signed8|int:Signed16;

type IntType2 i8|2;

function init() {
    xml:ProcessingInstruction style = xml `<?xml-stylesheet type="text/xsl" href="style.xsl"?>`;

    io:println(style[i8]); // @output <?xml-stylesheet type="text/xsl" href="style.xsl"?>

    IntType1 i9 = 0;
    io:println(style[i9]); // @output <?xml-stylesheet type="text/xsl" href="style.xsl"?>

    IntType2 i10 = 0;
    io:println(style[i10]); // @output <?xml-stylesheet type="text/xsl" href="style.xsl"?>

    1|0 i11 = 0;
    io:println(style[i11]); // @output <?xml-stylesheet type="text/xsl" href="style.xsl"?>

    int:Unsigned8|int:Unsigned32 i12 = 0;
    io:println(style[i12]); // @output <?xml-stylesheet type="text/xsl" href="style.xsl"?>

    int:Unsigned16|byte i13 = 0;
    io:println(style[i13]); // @output <?xml-stylesheet type="text/xsl" href="style.xsl"?>
}

Test-Case: output
Description: Test whether the static type of key expression is a subtype of int when the static type of the
             container expression is an xml:Comment.
Labels: member-access-expr, byte, int, int:Signed8, int:Signed16, int:Signed32, int:Unsigned8, int:Unsigned32,
        xml:Comment

function init() {
    xml:Comment comment = xml `<!--Comment-->`;

    int i0 = 0;
    io:println(comment[i0]); // @output <!--Comment-->

    int:Signed8 i1 = 0;
    io:println(comment[i1]); // @output <!--Comment-->

    int:Signed16 i2 = 0;
    io:println(comment[i2]); // @output <!--Comment-->

    int:Signed32 i3 = 0;
    io:println(comment[i3]); // @output <!--Comment-->

    int:Unsigned8 i4 = 0;
    io:println(comment[i4]); // @output <!--Comment-->

    int:Unsigned16 i5 = 0;
    io:println(comment[i5]); // @output <!--Comment-->

    int:Unsigned32 i6 = 0;
    io:println(comment[i6]); // @output <!--Comment-->

    byte i7 = 0;
    io:println(comment[i7]); // @output <!--Comment-->

    io:println(comment[0]); // @output <!--Comment-->
}

Test-Case: output
Description: Test whether the static type of key expression is a subtype of int when the static type of the
             container expression is an xml:Comment.
Labels: member-access-expr, byte, int, int:Signed8, int:Signed16, int:Signed32, int:Unsigned8, int:Unsigned32,
        xml:Comment

const i8 = 0;

type IntType1 int:Signed8|int:Signed16;

type IntType2 i8|2;

function init() {
    xml:Comment comment = xml `<!--Comment-->`;

    io:println(comment[i8]); // @output <!--Comment-->

    IntType1 i9 = 0;
    io:println(comment[i9]); // @output <!--Comment-->

    IntType2 i10 = 0;
    io:println(comment[i10]); // @output <!--Comment-->

    1|0 i11 = 0;
    io:println(comment[i11]); // @output <!--Comment-->

    int:Unsigned8|int:Unsigned32 i12 = 0;
    io:println(comment[i12]); // @output <!--Comment-->

    int:Unsigned16|byte i13 = 0;
    io:println(comment[i13]); // @output <!--Comment-->
}

Test-Case: output
Description: Test whether the static type of key expression is a subtype of int when the static type of the
             container expression is an xml:Text.
Labels: member-access-expr, byte, int, int:Signed8, int:Signed16, int:Signed32, int:Unsigned8, int:Unsigned32,
        xml:Text

function init() {
    xml:Text text = xml `text1 text2`;

    int i0 = 0;
    io:println(text[i0]); // @output text1 text2

    int:Signed8 i1 = 0;
    io:println(text[i1]); // @output text1 text2

    int:Signed16 i2 = 0;
    io:println(text[i2]); // @output text1 text2

    int:Signed32 i3 = 0;
    io:println(text[i3]); // @output text1 text2

    int:Unsigned8 i4 = 0;
    io:println(text[i4]); // @output text1 text2

    int:Unsigned16 i5 = 0;
    io:println(text[i5]); // @output text1 text2

    int:Unsigned32 i6 = 0;
    io:println(text[i6]); // @output text1 text2

    byte i7 = 0;
    io:println(text[i7]); // @output text1 text2

    io:println(text[0]); // @output text1 text2
}

Test-Case: output
Description: Test whether the static type of key expression is a subtype of int when the static type of the
             container expression is an xml:Text.
Labels: member-access-expr, byte, int, int:Signed8, int:Signed16, int:Signed32, int:Unsigned8, int:Unsigned32,
        xml:Text

const i8 = 0;

type IntType1 int:Signed8|int:Signed16;

type IntType2 i8|2;

function init() {
    xml:Text text = xml `text1 text2`;

    io:println(text[i8]); // @output text1 text2

    IntType1 i9 = 0;
    io:println(text[i9]); // @output text1 text2

    IntType2 i10 = 0;
    io:println(text[i10]); // @output text1 text2

    1|0 i11 = 0;
    io:println(text[i11]); // @output text1 text2

    int:Unsigned8|int:Unsigned32 i12 = 0;
    io:println(text[i12]); // @output text1 text2

    int:Unsigned16|byte i13 = 0;
    io:println(text[i13]); // @output text1 text2
}

Test-Case: output
Description: Test whether the static type of key expression is a subtype of int when the static type of the
             container expression is a user defined subtype of xml.
Fail-Issue: ballerina-platform/ballerina-lang#35008
Labels: member-access-expr, byte, int, int:Signed8, int:Signed16, int:Unsigned8, int:Unsigned32,
        module-type-decl, module-const-decl, xml, union-type

const i8 = 0;

type IntType1 int:Signed8|int:Signed16;

type IntType2 i8|3;

type XmlType1 xml:Text|xml:Comment;

type XmlType2 xml<xml:Element|xml:ProcessingInstruction>;

type XmlType3 XmlType1|XmlType2;

function init() {
    XmlType1 txt = xml `Hello!`;

    io:println(txt[0]); // @output Hello!

    io:println(txt[i8]); // @output Hello!

    IntType1 i9 = 0;
    io:println(txt[i9]); // @output Hello!

    XmlType2 ele = xml `<name>Sherlock Holmes</name>`;
    IntType2 i10 = 0;
    io:println(ele[i10]); // @output <name>Sherlock Holmes</name>

    XmlType3 ele2 = xml `<name>Sherlock Holmes</name>`;
    io:println(ele2[i10]); // @output <name>Sherlock Holmes</name>

    xml:Text|xml:ProcessingInstruction txt2 = xml `World`;
    0|2 i11 = 0;
    io:println(txt2[i11]); // @output World

    xml|xml<xml:Text> authors = xml `<name>Sherlock Holmes</name><name>Enid Blyton</name><name>Dan Brown</name><name>Nicholas Sparks</name>`;
    int:Unsigned8|int:Unsigned32 i12 = 2;
    io:println(authors[i12]); // @output name>Dan Brown</name>

    xml<xml:Text|xml:Comment>|xml<xml:ProcessingInstruction|xml:Element> ele3 = xml `<name>Dan Brown</name>`;
    int:Unsigned16|byte i13 = 0;
    io:println(ele3[i13]); // @output <name>Dan Brown</name>

    xml<xml:Element|xml:ProcessingInstruction> ele4 = xml `<name>Enid Blyton</name>`;
    io:println(ele4[0]); // @output <name>Enid Blyton</name>
}

Test-Case: output
Description: Test the result of evaluating a member access expression when basic type of the evaluated value of the
             container expression is an xml.
Labels: member-access-expr, is-expr, xml, xml:length

function init() {
    xml seq = xml `<?xml-stylesheet type="text/xsl" href="style.xsl"?><name>Sherlock Holmes</name><!--Comment--><name>Enid Blyton</name>Some Text<name>Dan Brown</name>`;
    io:println(seq.length()); // @output 6

    io:println(seq[0]); // @output <?xml-stylesheet type="text/xsl" href="style.xsl"?>
    io:println(seq[0] is xml); // @output true
    io:println(seq[0].length()); // @output 1

    io:println(seq[1]); // @output <name>Sherlock Holmes</name>
    io:println(seq[1] is xml); // @output true
    io:println(seq[1].length()); // @output 1

    io:println(seq[2]); // @output <!--Comment-->
    io:println(seq[2] is xml); // @output true
    io:println(seq[2].length()); // @output 1

    io:println(seq[3]); // @output <name>Enid Blyton</name>
    io:println(seq[3] is xml); // @output true
    io:println(seq[3].length()); // @output 1

    io:println(seq[4]); // @output Some Text
    io:println(seq[4] is xml); // @output true
    io:println(seq[4].length()); // @output 1

    io:println(seq[5]); // @output<name>Dan Brown</name>
    io:println(seq[5] is xml); // @output true
    io:println(seq[5].length()); // @output 1
}

Test-Case: output
Description: Test the result of evaluating a member access expression when basic type of the evaluated value (c) of the
             container expression is an xml and evaluated value (k) of the key expression is greater than or equal to
             its length (k >= length(c)).
Labels: member-access-expr, xml, value:toBalString

function init() {
    xml seq = xml `<?xml-stylesheet type="text/xsl" href="style.xsl"?><name>Sherlock Holmes</name><!--Comment--><name>Enid Blyton</name>Some Text<name>Dan Brown</name>`;

    // k == length(c)
    io:println(seq[6].toBalString()); // @output xml``

    // k > length(c)
    io:println(seq[10].toBalString()); // @output xml``
}

Test-Case: output
Description: Test the result of evaluating a member access expression when basic type of the evaluated value of the
             container expression is a builtin subtype of xml.
Labels: member-access-expr, is-expr, xml, xml:ProcessingInstruction, xml:Element, xml:Comment, xml:Text, xml:length

function init() {
    xml:ProcessingInstruction ins = xml `<?xml-stylesheet type="text/xsl" href="style.xsl"?>`;
    io:println(ins[0] is xml); // @output true
    io:println(ins[0].length()); // @output 1

    xml:Element ele = xml `<name>Sherlock Holmes</name>`;
    io:println(ele[0] is xml); // @output true
    io:println(ele[0].length()); // @output 1

    xml:Comment comment = xml `<!--Comment-->`;
    io:println(comment[0] is xml); // @output true
    io:println(comment[0].length()); // @output 1

    xml:Text text = xml `Some Text`;
    io:println(text[0] is xml); // @output true
    io:println(text[0].length()); // @output 1
}

Test-Case: output
Description: Test the result of evaluating a member access expression when basic type of the evaluated value (c) of the
             container expression is a builtin subtype of xml and evaluated value (k) of the key expression is greater
             than or equal to its length (k >= length(c)).
Labels: member-access-expr, xml:ProcessingInstruction, xml:Element, xml:Comment, xml:Text, value:toBalString

function init() {
    xml:ProcessingInstruction ins = xml `<?xml-stylesheet type="text/xsl" href="style.xsl"?>`;
    // k == length(c)
    io:println(ins[1].toBalString()); // @output xml``
    // k > length(c)
    io:println(ins[4].toBalString()); // @output xml``

    xml:Element ele = xml `<name>Sherlock Holmes</name>`;
    // k == length(c)
    io:println(ele[1].toBalString()); // @output xml``
    // k > length(c)
    io:println(ele[4].toBalString()); // @output xml``

    xml:Comment comment = xml `<!--Comment-->`;
    // k == length(c)
    io:println(comment[1].toBalString()); // @output xml``
    // k > length(c)
    io:println(comment[4].toBalString()); // @output xml``

    xml:Text text = xml `Some Text`;
    // k == length(c)
    io:println(text[1].toBalString()); // @output xml``
    // k > length(c)
    io:println(text[4].toBalString()); // @output xml``
}

Test-Case: output
Description: Test the result of evaluating a member access expression when basic type of the evaluated value of the
             container expression is a user defined subtype of xml.
Labels: member-access-expr, is-expr, xml, xml:ProcessingInstruction, xml:Element, xml:Comment, xml:length, union-type,
        module-type-decl

type XmlType1 xml<xml:Element|xml:ProcessingInstruction>;

type XmlType2 xml:Comment;

function init() {
    xml<xml:Element|xml:ProcessingInstruction> ins = xml `<?xml-stylesheet type="text/xsl" href="style.xsl"?>`;
    io:println(ins[0] is xml); // @output true
    io:println(ins[0].length()); // @output 1

    XmlType1 ele = xml `<name>Sherlock Holmes</name>`;
    io:println(ele[0] is xml); // @output true
    io:println(ele[0].length()); // @output 1

    XmlType2 comment = xml `<!--Comment-->`;
    io:println(comment[0] is xml); // @output true
    io:println(comment[0].length()); // @output 1
}

Test-Case: output
Description: Test the result of evaluating a member access expression when basic type of the evaluated value (c) of the
             container expression is a builtin subtype of xml and evaluated value (k) of the key expression is greater
             than or equal to its length (k >= length(c)).
Labels: member-access-expr, xml:ProcessingInstruction, xml:Element, xml:Comment, value:toBalString, union-type,
        module-type-decl

type XmlType1 xml<xml:Element|xml:ProcessingInstruction>;

type XmlType2 xml:Comment;

function init() {
    xml<xml:Element|xml:ProcessingInstruction> ins = xml `<?xml-stylesheet type="text/xsl" href="style.xsl"?>`;
    // k == length(c)
    io:println(ins[1].toBalString()); // @output xml``
    // k > length(c)
    io:println(ins[4].toBalString()); // @output xml``

    XmlType1 ele = xml `<name>Sherlock Holmes</name>`;
    // k == length(c)
    io:println(ele[1].toBalString()); // @output xml``
    // k > length(c)
    io:println(ele[4].toBalString()); // @output xml``

    XmlType2 comment = xml `<!--Comment-->`;
    // k == length(c)
    io:println(comment[1].toBalString()); // @output xml``
    // k > length(c)
    io:println(comment[4].toBalString()); // @output xml``
}

Test-Case: output
Description: Test the static type of member access expression when static type of the container expression is
             a subtype of xml<M>.
Labels: member-access-expr, is-expr, union-type, xml, xml:Element, xml:Comment, xml:Text, xml:ProcessingInstruction

function init() {
    xml seq = xml `<?xml-stylesheet type="text/xsl" href="style.xsl"?><name>Sherlock Holmes</name><!--Comment--><name>Enid Blyton</name>Some Text<name>Dan Brown</name>`;

    xml:Element|xml:Comment|xml:ProcessingInstruction|xml:Text ins = seq[0];
    io:println(ins); // @output <?xml-stylesheet type="text/xsl" href="style.xsl"?>
    io:println(seq[0] is xml:ProcessingInstruction); // @output true

    xml:Element|xml:Comment|xml:ProcessingInstruction|xml:Text ele = seq[3];
    io:println(ele); // @output <name>Enid Blyton</name>
    io:println(seq[3] is xml:Element); // @output true

    xml:Comment comment = xml `<!--Comment-->`;
    xml:Comment commentMem = comment[0];
    io:println(commentMem); // @output <!--Comment-->
    io:println(comment[0] is xml:Comment); // @output true

    xml<xml:Text> ele2 = xml `Text`;
    xml:Text eleMem = ele2[0];
    io:println(eleMem); // @output Text
    io:println(ele2[0] is xml:Text); // @output true

    XmlType2 com = xml `<!--Comment1-->`;
    xml:Comment comMem = com[0];
    io:println(comMem); // @output <!--Comment1-->
    io:println(com[0] is xml:Comment); // @output true
}

Test-Case: output
Description: Test the static type of member access expression when static type of the container expression is
             a subtype of xml<M>.
Fail-Issue: ballerina-platform/ballerina-lang#35019
Labels: member-access-expr, is-expr, module-type-decl, union-type, xml, xml:Element, xml:Comment, xml:Text,
        xml:ProcessingInstruction

type XmlType1 xml<xml:Element|xml:ProcessingInstruction>;

function init() {
    xml<xml:Comment> xml1 = xml `<!--Comment1--><!--Comment2-->`;
    xml:Comment mem1 = xml1[1];

    xml<xml:ProcessingInstruction> xml2 = xml `<?xml-stylesheet type="text/xsl" href="style.xsl"?>`;
    xml:ProcessingInstruction mem2 = xml2[0];

    xml<xml:Element> xml3 = xml `<name>Sherlock Holmes</name><name>Enid Blyton</name>`;
    xml:Element mem3 = xml3[1];

    XmlType1 xml4 = xml `<name>Enid Blyton</name><name>Dan Brown</name>`;
    xml:Element|xml:ProcessingInstruction mem4 = xml4[1];

    xml<xml:Element|xml:Comment|xml:Text> xml5 = xml `<name>Enid Blyton</name><name>Dan Brown</name>`;
    xml:Element|xml:Comment|xml:Text mem5 = xml5[0];
}

Test-Case: output
Description: Test assigning the result of evaluating a member access expression to var when basic type of the evaluated
             value of the container expression is an xml.
Labels: member-access-expr, is-expr, xml, xml:ProcessingInstruction, xml:Element, xml:Comment, xml:Text, xml:length

function init() {
    xml val = xml `<name>Sherlock Holmes</name><name>Enid Blyton</name>`;
    var mem = val[1];
    io:println(mem); // @output <name>Enid Blyton</name>
    xml:Element|xml:Comment|xml:ProcessingInstruction|xml:Text _ = mem;

    xml:Text val2 = xml `This is a text`;
    var mem2 = val2[0];
    io:println(mem2); // @output This is a text
    xml:Text _ = mem2;
}

Test-Case: output
Description: Test xml template expression as container expression whose static type is xml.
Labels: member-access-expr, xml-template-expr

function init() {
    io:println(xml `<name>Sherlock Holmes</name><name>Enid Blyton</name>`[1]); // @output <name>Enid Blyton</name>
}

Test-Case: output
Description: Test variable reference expression as container expression whose static type is xml.
Labels: member-access-expr, xml, variable-reference-expr

function init() {
    xml authors = xml `<name>Enid Blyton</name><name>Dan Brown</name>`;
    io:println(authors[1]); // @output <name>Dan Brown</name>
}

Test-Case: output
Description: Test field access expression as container expression whose static type is xml.
Labels: member-access-expr, field-access-expr, mapping-constructor-expr, record-type, xml

type Record record {|
    xml authors;
|};

function init() {
    Record rec = {authors: xml `<name>Enid Blyton</name><name>Dan Brown</name>`};
    io:println(rec.authors[0]); // @output <name>Enid Blyton</name>
}

Test-Case: output
Description: Test function call expression as container expression whose static type is xml.
Labels: member-access-expr, function-call-expr, xml

function init() {
    io:println(getXml()[1]); // @output <name>Dan Brown</name>
}

function getXml() returns xml {
    return xml `<name>Enid Blyton</name><name>Dan Brown</name>`;
}

Test-Case: output
Description: Test method call expression as container expression whose static type is xml.
Labels: member-access-expr, method-call-expr, module-class-defn, explicit-new-expr, xml

class Book {
    function geAuthors(xml author1) returns xml {
        return author1 + xml `<name>Dan Brown</name>`;
    }
}

function init() {
    Book book = new Book();
    io:println(book.geAuthors(xml `<name>Enid Blyton</name>`)[1]); // @output <name>Dan Brown</name>
}

Test-Case: output
Description: Test let expression expression as container expression whose static type is xml.
Labels: member-access-expr, let-expr, string

function init() {
    io:println((let xml b = xml `<name>Enid Blyton</name><name>Dan Brown</name>` in b)[1]); // @output <name>Dan Brown</name>
}

Test-Case: output
Description: Test type cast expression as container expression whose static type is xml.
Labels: member-access-expr, xml, optional-type, type-cast-expr

function init() {
    xml? value = xml `<name>Enid Blyton</name>`;
    io:println((<xml>value)[0]); // @output <name>Enid Blyton</name>
}

Test-Case: output
Description: Test additive expression as container expression whose static type is xml.
Labels: member-access-expr, additive-expr, xml, string

function init() {
    io:println((xml `<name>Enid Blyton</name>` + xml `<name>Dan Brown</name>`)[1]); // @output <name>Dan Brown</name>
    io:println((xml `Text1` + "Text2")[0]); // @output Text1Text2
}

Test-Case: output
Description: Test conditional expression as container expression whose static type is xml.
Labels: member-access-expr, conditional-expr, xml, is-expr, optional-type, nil-literal

function init() returns error? {
    xml? msg = ();
    io:println((msg is xml ? xml `<name>Enid Blyton</name>` : xml `<name>Dan Brown</name>`)[0]); // @output <name>Dan Brown</name>
}

Test-Case: output
Description: Test checking expression as container expression whose static type is xml.
Labels: member-access-expr, check, checkpanic, error, xml, union-type

function init() returns error? {
    xml|error val = xml `<name>Enid Blyton</name>`;
    io:println((check val)[0]); // @output <name>Enid Blyton</name>
    io:println((checkpanic val)[0]); // @output <name>Enid Blyton</name>
}

Test-Case: output
Description: Test query expression as container expression whose static type is xml.
Labels: member-access-expr, query-expr, array-type, list-constructor-expr, xml

function init() returns error? {
    xml books = xml `<book>
                           <name>Sherlock Holmes</name>
                           <author>Sir Arthur Conan Doyle</author>
                     </book>
                     <book>
                           <name>The Da Vinci Code</name>
                           <author>Dan Brown</author>
                     </book>`;

    io:println((from var x in books/<name> select x)[1]); // @output <name>The Da Vinci Code</name>
}

Test-Case: output
Description: Test int literal as key expression with container expression whose static type is xml.
Labels: member-access-expr, xml, DecimalNumber

function init() returns error? {
    xml val = xml `<!--Some Comment--><name>Enid Blyton</name>Some Text<name>Dan Brown</name>`;
    io:println(val[2]); // @output Some Text
}

Test-Case: output
Description: Test variable reference as key expression with container expression whose static type is xml.
Labels: member-access-expr, variable-reference-expr, xml, int

function init() returns error? {
    xml val = xml `<!--Some Comment--><name>Enid Blyton</name>Some Text<name>Dan Brown</name>`;
    int i = 1;
    io:println(val[i]); // @output <name>Enid Blyton</name>
}

Test-Case: output
Description: Test field access expression as key expression with container expression whose static type is xml.
Labels: member-access-expr, field-access-expr, record-type, mapping-constructor-expr, int, xml

type Record record {|
    int index;
|};

function init() {
    xml val = xml `<!--Some Comment--><name>Enid Blyton</name>Some Text<name>Dan Brown</name>`;
    Record rec = {index: 1};
    io:println(val[rec.index]); // @output <name>Enid Blyton</name>
}

Test-Case: output
Description: Test member access expression as key expression with container expression whose static type is xml.
Labels: member-access-expr, array-type, int, list-constructor-expr, xml

function init() {
    xml val = xml `<!--Some Comment--><name>Enid Blyton</name>Some Text<name>Dan Brown</name>`;
    int[] indices = [3, 1, 2];
    io:println(val[indices[0]]); // @output <name>Dan Brown</name>
}

Test-Case: output
Description: Test functional call as key expression with container expression whose static type is xml.
Labels: member-access-expr, function-call-expr, int, xml

function init() {
    xml val = xml `<!--Some Comment--><name>Enid Blyton</name>Some Text<name>Dan Brown</name>`;
    io:println(val[getPosition()]); // @output Some Text
}

function getPosition() returns int {
    return 2;
}

Test-Case: output
Description: Test method call as key expression with container expression whose static type is xml.
Labels: member-access-expr, explicit-new-expr, module-class-defn, method-call-expr, int, xml

class Position {
    function getPosition(int pos) returns int {
        return pos + 1;
    }
}

function init() {
    xml val = xml `<!--Some Comment--><name>Enid Blyton</name>Some Text<name>Dan Brown</name>`;
    Position pos = new Position();
    io:println(val[pos.getPosition(-1)]); // @output <!--Some Comment-->
}

Test-Case: output
Description: Test let expression as key expression with container expression whose static type is xml.
Labels: member-access-expr, let-expr, int, xml

function init() {
    xml val = xml `<!--Some Comment--><name>Enid Blyton</name>Some Text<name>Dan Brown</name>`;
    io:println(val[let int i = 1 + 2 in i]); // @output <name>Dan Brown</name>
}

Test-Case: output
Description: Test type cast expression as key expression with container expression whose static type is xml.
Labels: member-access-expr, type-cast-expr, int, xml

function init() {
    xml val = xml `<!--Some Comment--><name>Enid Blyton</name>Some Text<name>Dan Brown</name>`;
    io:println(val[<int> 3]); // @output <name>Dan Brown</name>
}

Test-Case: output
Description: Test unary numeric expression as key expression with container expression whose static type is xml.
Labels: member-access-expr, unary-numeric-expr, xml, DecimalNumber

function init() {
    xml val = xml `<!--Some Comment--><name>Enid Blyton</name>Some Text<name>Dan Brown</name>`;
    io:println(val[+2]); // @output Some Text
    io:println(val[-(-2)]); // @output Some Text
    io:println(val[~(-2)]); // @output <name>Enid Blyton</name>
}

Test-Case: output
Description: Test additive expression as key expression with container expression whose static type is xml.
Labels: member-access-expr, additive-expr, DecimalNUmber, xml

function init() {
    xml val = xml `<!--Some Comment--><name>Enid Blyton</name>Some Text<name>Dan Brown</name>`;
    io:println(val[0 + 1]); // @output <name>Enid Blyton</name>
    io:println(val[3 - 2]); // @output <name>Enid Blyton</name>
}

Test-Case: output
Description: Test multiplicative expression as key expression with container expression whose static type is xml.
Labels: member-access-expr, multiplicative-expr, DecimalNumber, xml

function init() {
    xml val = xml `<!--Some Comment--><name>Enid Blyton</name>Some Text<name>Dan Brown</name>`;
    io:println(val[1 * 2]); // @output Some Text
    io:println(val[4 / 2]); // @output Some Text
    io:println(val[5 % 2]); // @output <name>Enid Blyton</name>
}

Test-Case: output
Description: Test shift expression as key expression with container expression whose static type is xml.
Labels: member-access-expr, shift-expr, DecimalNumber, xml

function init() {
    xml val = xml `<!--Some Comment--><name>Enid Blyton</name>Some Text<name>Dan Brown</name>`;
    io:println(val[1 << 1]); // @output Some Text
    io:println(val[4 >> 2]); // @output <name>Enid Blyton</name>
}

Test-Case: output
Description: Test binary bitwise expression as key expression with container expression whose static type is xml.
Labels: member-access-expr, binary-bitwise-expr, DecimalNumber, xml

function init() {
    xml val = xml `<!--Some Comment--><name>Enid Blyton</name>Some Text<name>Dan Brown</name>`;
    io:println(val[2 & 6]); // @output Some Text
    io:println(val[1 ^ 1]); // @output <!--Some Comment-->
}

Test-Case: output
Description: Test checking expression as key expression with container expression whose static type is xml.
Labels: member-access-expr, check, checkpanic, error, int, xml, union-type, optional-type

function init() returns error? {
    xml val = xml `<!--Some Comment--><name>Enid Blyton</name>Some Text<name>Dan Brown</name>`;
    int|error pos = 3;

    io:println(val[check pos]); // @output <name>Dan Brown</name>
    io:println(val[checkpanic pos]); // @output <name>Dan Brown</name>
}

Test-Case: output
Description: Test conditional expression as key expression with container expression whose static type is xml.
Labels: member-access-expr, conditional-expr, xml, is-expr, optional-type, int

function init() {
    xml val = xml `<!--Some Comment--><name>Enid Blyton</name>Some Text<name>Dan Brown</name>`;
    int? pos = 1;
    io:println(val[pos is int ? pos : 0]); // @output <name>Enid Blyton</name>!
}

Test-Case: output
Description: Test member access expression at module level.
Labels: member-access-expr, xml, module-var-decl

xml val = xml `<!--Some Comment--><name>Enid Blyton</name>Some Text<name>Dan Brown</name>`;

xml mem = val[3];

function init() {
    io:println(mem); // @output <name>Dan Brown</name>
}

Test-Case: output
Description: Test member access expression when the basic type of the container expression is inferred as xml.
Labels: member-access-expr, xml, is-expr, var

function init() {
    var val = xml `<!--Some Comment--><name>Enid Blyton</name>Some Text<name>Dan Brown</name>`;
    io:println(val is xml); // @output true
    io:println(val[3]); // @output <name>Dan Brown</name>
}

Test-Case: output
Description: Test member access expression with container expression of basic type xml as array member.
Labels: member-access-expr, array-type, xml, list-constructor-expr

function init() {
    xml val = xml `<!--Some Comment--><name>Enid Blyton</name>Some Text<name>Dan Brown</name>`;

    xml[] mem = [val[1], val[3], val[0]];
    io:println(mem[1]); // @output <name>Dan Brown</name>
}

Test-Case: output
Description: Test member access expression with container expression of basic type xml as default expression
             for a field.
Labels: member-access-expr, module-var-decl, record-type, xml, module-type-decl, mapping-constructor-expr,
        final, readonly

final xml & readonly val = xml `<!--Some Comment--><name>Enid Blyton</name>Some Text<name>Dan Brown</name>`;

type Record record {|
    xml member = val[0];
|};

function init() {
    Record rec = {};
    io:println(rec.member); // @output <!--Some Comment-->
}

Test-Case: output
Description: Test member access expression with container expression of basic type xml as defaultable
             function parameter.
Labels: member-access-expr, defaultable-param, function-call-expr, module-var-decl, xml, final, readonly

final xml & readonly val = xml `<!--Some Comment--><name>Enid Blyton</name>Some Text<name>Dan Brown</name>`;

function init() {
    io:println(getMember()); // @output Some Text
}

function getMember(xml member = val[2]) returns xml {
    return member;
}

Test-Case: output
Description: Test member access expression with container expression of basic type xml as expression in
             return statement.
Labels: member-access-expr, return-stmt, function-call-expr, xml

function init() {
    io:println(getMember(xml `<name>Enid Blyton</name><name>Dan Brown</name>`)); // @output <name>Dan Brown</name>
}

function getMember(xml member) returns xml {
    return member[1];
}

Test-Case: output
Description: Test accessing members of a member access expression.
Labels: member-access-expr,

type Record record {
    xml[][] a;
};

function init() {
    xml x = xml `<name>Enid Blyton</name><name>Dan Brown</name>`;
    io:println(x[1][0][0][0][0]); // @output <name>Dan Brown</name>

    xml[][] arr1 = [[xml `<name>Enid Blyton</name><name>Dan Brown</name>`, xml `Some Text`], [xml `<name>Enid Blyton</name><name>Dan Brown</name>`, xml `<!--Comment-->`], [xml `<name>Dan Brown</name>`]];
    io:println(arr1[1][1][0][0][0]); // @output <!--Comment-->

    [int, [xml...]] t1 = [1, [xml `<name>Enid Blyton</name><name>Dan Brown</name>`, xml `Some Text`, xml `<!--Comment-->`]];
    io:println(t1[1][0][1][0][0]); // @output <name>Dan Brown</name>

    Record rec = {a: [[xml `<name>Enid Blyton</name><name>Dan Brown</name>`, xml `Some Text`], [xml `<name>Enid Blyton</name><name>Dan Brown</name>`, xml `<!--Comment-->`], [xml `<name>Dan Brown</name>`]]};
    io:println(rec["a"][1][0][1][0][0]); // @output <name>Dan Brown</name>
}

Test-Case: error
Description: Test assigning a value to member access expression.
Labels: member-access-expr, xml, xml:Element, xml:Text, xml:Comment, union-type

function errorFunction() {
    xml e = xml `<name>Enid Blyton</name><name>Dan Brown</name>`;
    e[1] = xml `<name>Nicholas Sparks</name>`; // @error cannot update an xml sequence

    xml:Element e2 = xml `<name>Enid Blyton</name>`;
    e[0] = xml `<name>Nicholas Sparks</name>`; // @error cannot update an xml sequence

    xml:Text|xml:Comment e3 = xml `Text`;
    e[0] = xml `Another Text`; // @error cannot update an xml sequence
}

Test-Case: error
Description: Test key expression with invalid static type.
Labels: member-access-expr, xml

function errorFunction() {
    xml e = xml `<name>Enid Blyton</name><name>Dan Brown</name>`;
    _ = e["0"]; // @error expected a value of subtype int as key
}

Test-Case: error
Description: Test assigning result of member access expression to an invalid type.
Labels: member-access-expr, xml, string

function errorFunction() {
    xml e = xml `<name>Enid Blyton</name><name>Dan Brown</name>`;
    string _ = e[1]; // @error @error expected string, found xml
}

Test-Case: error
Description: Test accessing members of an invalid structure.
Fail-Issue: ballerina-platform/ballerina-lang#35032
Labels: member-access-expr, xml, optional-type

function errorFunction() {
    xml? e = xml `<name>Enid Blyton</name><name>Dan Brown</name>`;
    _ = e[1]; // @error type 'xml?' does not support member access
}

Test-Case: error
Description: Test missing key expression in member access expression.
Labels: member-access-expr, xml

function errorFunction() {
    xml e = xml `<name>Enid Blyton</name><name>Dan Brown</name>`;
    _ = e[]; // @error missing key expression
}
