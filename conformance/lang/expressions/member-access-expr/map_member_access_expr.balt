Test-Case: parser-error
Description: Test missing key expression in member access expression.
Labels: member-access-expr, mapping-constructor-expr, map-type, int, string, union-type

function errorFunction() {
    map<int|string> p1 = {id: 1, name: "Mike"};
    _ = p1[]; // @error missing key expression
}

Test-Case: output
Description: Test whether the static type of key expression is subtype of string when the basic type of the
             container expression is a map.
Labels: member-access-expr, module-type-defn, module-const-decl, map-type, union-type, mapping-constructor-expr,
        string, int

const idf = "id";

type StringType1 "id"|"name";

function init() {
    map<int|string> p1 = {id: 1, name: "John", age: 23};

    io:println(p1["id"]); // @output 1

    io:println(p1[idf]); // @output 1

    string idf1 = "name";
    io:println(p1[idf1]); // @output John

    StringType1 idf2 = "name";
    io:println(p1[idf2]); // @output John
}

Test-Case: error
Description: Test key expression with invalid static type.
Labels: member-access-expr, mapping-constructor-expr, map-type, int, string, union-type, any

function errorFunction() {
    map<int|string> p1 = {id: 1, name: "Mike"};

    _ = p1[1]; // @error expected a key of type string, found int

    int a = 1;
    _ = p1[a]; // @error expected a key of type string, found int

    int|string b = "id";
    _ = p1[b]; // @error expected a key of type string, found (int|string)

    any c = "id";
    _ = p1[c]; // @error expected a key of type string, found any
}

Test-Case: output
Description: Test the result of evaluating a member access expression when basic type of the evaluated value of the
             container expression is a map.
Labels: member-access-expr, map-type, union-type, int, string, mapping-constructor-expr, value:toBalString

function init() {
    map<int|string> p1 = {id: 1, name: "John", age: 23};

    io:println(p1["id"]); // @output 1

    io:println(p1["name"]); // @output John

    io:println(p1["age"]); // @output 23

    io:println(p1["address"].toBalString()); // @output ()
}

Test-Case: output
Description: Test the result of evaluating a member access expression when basic type of the evaluated value of the
             container expression is a union of nil and map.
Labels: member-access-expr, string, map-type, optional-type, is-expr, nil-literal, value:toBalString

function init() {
    map<string>? p = ();

    io:println(p is ()); // @output true
    io:println(p["id"].toBalString()); // @output ()
}

Test-Case: output
Description: Test the static type of member access expression when the container expression is of map type.
Labels: member-access-expr, int, string, union-type, map-type, mapping-constructor-expr, optional-type, value:toBalString

function init() {
    map<int|string> p1 = {id: 1, name: "John", age: 23};

    int|string? id = p1["id"];
    io:println(id); // @output 1

    int|string? nm = p1["name"];
    io:println(nm); // @output John

    int|string? age = p1["age"];
    io:println(age); // @output 23

    int|string? addr = p1["addr"];
    io:println(addr.toBalString()); // @output ()
}

Test-Case: output
Description: Test the static type of member access expression when the static type of the container expression
             contains nil.
Labels: member-access-expr, int, string, union-type, map-type, mapping-constructor-expr, optional-type, value:toBalString

function init() {
    map<int|string>? p1 = {id: 1, name: "John", age: 23};

    int|string? id = p1["id"];
    io:println(id); // @output 1

    int|string? nm = p1["name"];
    io:println(nm); // @output John

    int|string? age = p1["age"];
    io:println(age); // @output 23

    int|string? addr = p1["addr"];
    io:println(addr.toBalString()); // @output ()
}

Test-Case: error
Description: Test assigning result of member access expression to an invalid type.
Labels: member-access-expr, mapping-constructor-expr, map-type, int, string, union-type

function errorFunction() {
    map<int|string> p1 = {id: 1, name: "Mike"};

    int|string _ = p1["name"]; // @error expected a int|string, static type of the accessed value is int|string?
}

Test-Case: output
Description: Test field access expression as container expression of type map.
Labels: member-access-expr, field-access-expr, module-type-defn, record-type, map-type, mapping-constructor-expr,
        union-type, int, string

type Record record {|
    map<int|string> p;
|};

function init() {
    Record rec = {p: {id: 1, name: "John", age: 23}};

    io:println(rec.p["id"]); // @output 1
}

Test-Case: output
Description: Test member access expression as container expression of type map.
Labels: member-access-expr, module-type-defn, record-type, map-type, mapping-constructor-expr, union-type, int, string

type Record record {|
    map<int|string> p;
|};

function init() {
    Record rec = {p: {id: 1, name: "John", age: 23}};

    io:println(rec["p"]["id"]); // @output 1
}

Test-Case: output
Description: Test function call expression as container expression of type map.
Labels: member-access-expr, function-call-expr, map-type, mapping-constructor-expr, union-type, int, string

function init() {
    io:println(getMap()["id"]); // @output 1
}

function getMap() returns map<int|string> {
    return {id: 1, name: "John", age: 23};
}

Test-Case: output
Description: Test method call expression as container expression of type map.
Labels: member-access-expr, method-call-expr, module-class-defn, explicit-new-expr, map-type, mapping-constructor-expr,
        union-type, int, string

class Map {
    function getMap() returns map<int|string> {
        return {id: 1, name: "John", age: 23};
    }
}

function init() {
    Map m = new;
    io:println(m.getMap()["name"]); // @output John
}

Test-Case: output
Description: Test let expression expression as container expression of type map.
Labels: member-access-expr, let-expr, map-type, mapping-constructor-expr, union-type, int, string

function init() {
    io:println((let map<int|string> p = {id: 1, name: "John"} in p)["name"]); // @output John
}

Test-Case: output
Description: Test type cast expression as container expression of type map.
Labels: member-access-expr, optional-type, type-cast-expr, map-type, mapping-constructor-expr, union-type, int, string

function init() {
    map<int|string>? p = {id: 1, name: "John"};
    io:println((<map<int|string>> p)["name"]); // @output John
}

Test-Case: output
Description: Test conditional expression as container expression of type map.
Labels: member-access-expr, conditional-expr, map-type, mapping-constructor-expr, union-type, int, string,
        relational-expr

function init() {
    int c = 4;
    map<int|string> p1 = {id: 1, name: "John"};
    map<int|string> p2 = {id: 3, name: "Mike"};

    io:println((c <= 2 ? p1 : p2)["name"]); // @output Mike
}

Test-Case: output
Description: Test checking expression as container expression of type map.
Labels: member-access-expr, check, checkpanic, error-type, map-type, mapping-constructor-expr, union-type, int, string,
        optional-type

function init() returns error? {
    map<int|string>|error p = {id: 3, name: "Mike"};

    io:println((check p)["name"]); // @output Mike
    io:println((checkpanic p)["name"]); // @output Mike
}

Test-Case: output
Description: Test field access expression as key expression with container expression of type map.
Labels: member-access-expr, field-access-expr, module-type-defn, record-type, mapping-constructor-expr, map-type,
        int, string, union-type

type Record record {|
    string f1;
|};

function init() {
    map<int|string> p = {id: 3, name: "Mike"};
    Record r = {f1: "name"};

    io:println(p[r.f1]); // @output Mike
}

Test-Case: output
Description: Test member access expression as key expression with container expression of type map.
Labels: member-access-expr, field-access-expr, module-type-defn, record-type, mapping-constructor-expr, map-type,
        int, string, union-type

type Record record {|
    string f1;
|};

function init() {
    map<int|string> p = {id: 3, name: "Mike"};
    Record r = {f1: "name"};

    io:println(p[r["f1"]]); // @output Mike
}

Test-Case: output
Description: Test functional call as key expression with container expression of type map.
Labels: member-access-expr, function-call-expr, mapping-constructor-expr, map-type, int, string, union-type

function init() {
    map<int|string> p = {id: 3, name: "Mike"};

    io:println(p[getField()]); // @output Mike
}

function getField() returns string {
    return "name";
}

Test-Case: output
Description: Test method call as key expression with container expression of type map.
Labels: member-access-expr, explicit-new-expr, module-class-defn, method-call-expr, mapping-constructor-expr,
        map-type, int, string, union-type

class Field {
    function getField() returns string {
        return "name";
    }
}

function init() {
    map<int|string> p = {id: 3, name: "Mike"};
    Field f = new;

    io:println(p[f.getField()]); // @output Mike
}

Test-Case: output
Description: Test let expression as key expression with container expression of type map.
Labels: member-access-expr, let-expr, mapping-constructor-expr, map-type, int, string, union-type

function init() {
    map<int|string> p = {id: 3, name: "Mike"};

    io:println(p[let string i = "id" in i]); // @output 3
}

Test-Case: output
Description: Test type cast expression as key expression with container expression of type map.
Labels: member-access-expr, type-cast-expr, mapping-constructor-expr, map-type, int, string, union-type

function init() {
    map<int|string> p = {id: 3, name: "Mike"};

    io:println(p[<string> "id"]); // @output 3
}

Test-Case: output
Description: Test additive expression as key expression with container expression of type map.
Labels: member-access-expr, additive-expr, mapping-constructor-expr, map-type, int, string, union-type

function init() {
    map<int|string> p = {id: 3, name: "Mike"};

    io:println(p["na" + "me"]); // @output Mike
}

Test-Case: output
Description: Test checking expression as key expression with container expression of type map.
Labels: member-access-expr, check, checkpanic, error-type, mapping-constructor-expr, map-type, int, string,
        union-type, optional-type

function init() returns error? {
    map<int|string> p = {id: 3, name: "Mike"};
    string|error nm = "name";

    io:println(p[check nm]); // @output Mike
    io:println(p[checkpanic nm]); // @output Mike
}

Test-Case: output
Description: Test conditional expression as key expression with container expression of type map.
Labels: member-access-expr, conditional-expr, mapping-constructor-expr, map-type, int, string, union-type,
        optional-type

function init() {
    map<int|string> p = {id: 3, name: "Mike"};
    string? nm = "name";

    io:println(p[nm is string ? "name" : ""]); // @output Mike
}

Test-Case: output
Description: Test member access expression at module level.
Labels: member-access-expr, module-init-var-decl, mapping-constructor-expr, map-type, int, string, union-type, optional-type

map<int|string> p = {id: 3, name: "Mike"};

int|string? nm = p["name"];

function init() {
    io:println(nm); // @output Mike
}

Test-Case: output
Description: Test member access expression with container expression of type map as array member.
Labels: member-access-expr, array-type, list-constructor-expr, mapping-constructor-expr, map-type, int, string,
        union-type, optional-type

function init() {
    map<int|string> p1 = {id: 1, name: "Mike"};
    map<int|string> p2 = {id: 3, name: "John"};

    (int|string?)[] arr = [p1["name"], p2["name"]];

    io:println(arr[0]); // @output Mike
}

Test-Case: output
Description: Test member access expression with container expression of type map as default expression
             for a field.
Labels: member-access-expr, module-init-var-decl, module-type-defn, record-type, readonly-type, field-access-expr,
        mapping-constructor-expr, map-type, int, string, union-type, optional-type

final map<int|string> & readonly p1 = {id: 1, name: "Mike"};

type Record record {|
    int|string? a = p1["name"];
|};

function init() {
    Record r = {};
    io:println(r.a); // @output Mike
}

Test-Case: output
Description: Test member access expression with container expression of type map as defaultable
             function parameter.
Labels: member-access-expr, defaultable-param, function-call-expr, module-init-var-decl, module-type-defn, record-type,
        mapping-constructor-expr, map-type, int, string, union-type, optional-type

final map<int|string> & readonly p1 = {id: 1, name: "Mike"};

function init() {
    io:println(getRecord()); // @output 1
}

function getRecord(int|string? id = p1["id"]) returns int|string? {
    return id;
}

Test-Case: output
Description: Test member access expression with container expression of type map as expression in
             return statement.
Labels: member-access-expr, return-stmt, function-call-expr, mapping-constructor-expr, map-type, int, string,
        union-type, optional-type

function init() {
    io:println(getRecordId()); // @output 1
}

function getRecordId() returns int|string? {
    map<int|string> p1 = {id: 1, name: "Mike"};
    return p1["id"];
}

Test-Case: output
Description: Test assigning a value to member access expression.
Labels: member-access-expr, mapping-constructor-expr, map-type, int, string, union-type

function init() {
    map<int|string> p1 = {id: 1, name: "Mike"};

    p1["name"] = "Michael";

    io:println(p1["name"]); // @output Michael
}

Test-Case: error
Description: Test accessing members of an invalid structure.
Labels: member-access-expr, mapping-constructor-expr, map-type, int, string, union-type, error-type

function errorFunction() {
    map<int|string>|error p1 = {id: 1, name: "Mike"};

    _ = p1["name"]; // @error type (map<int|string>|error) does not support member access
}

Test-Case: error
Description: Test assigning an invalid value to member access expression.
Labels: member-access-expr, mapping-constructor-expr, map-type, int, string, union-type

function errorFunction() {
    map<int|string> p1 = {id: 1, name: "Mike"};

    p1["name"] = 10.5; // @error expected (int|string), found float
}
