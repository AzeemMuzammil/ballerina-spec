Test-Case: output
Description: Test whether the static type of key expression is subtype of int when the basic type of the
             container expression is a tuple.
Labels: member-access-expr, tuple-type, int, string, float, list-constructor-expr, module-type-decl, module-const-decl,
        union-type

const i1 = 0;
const i2 = 5;

type IntType1 3|4;

type IntType2 i1|i2;

function init() {
    [int, string, float...] t = [10, "ABC", 10.5, 20.5, 30.5, 40.5];

    int i0 = 0;
    io:println(t[i0]); // @output 10

    io:println(t[1]); // @output ABC

    IntType1 i3 = 4;
    io:println(t[i3]); // @output 30.5

    io:println(t[i1]); // @output 10

    IntType2 i4 = 5;
    io:println(t[i4]); // @output 40.5
}

Test-Case: output
Description: Test whether the static type of key expression is subtype of int when the basic type of the
             container expression is a tuple.
Fail-Issue: ballerina-platform/ballerina-lang#35045
Labels: member-access-expr, tuple-type, int, string, float, list-constructor-expr, module-type-decl, byte, int:Signed8,
        int:Signed16, int:Signed32, union-type

type IntType1 int:Signed8|int:Signed16;

function init() {
    [int, string, float...] t = [10, "ABC", 10.5, 20.5, 30.5, 40.5];

    int:Signed8 i1 = 1;
    io:println(t[i1]); // @output ABC

    byte i2 = 2;
    io:println(t[i2]); // @output 10.5

    int:Signed32|int:Signed16 i3 = 3;
    io:println(t[i3]); // @output 20.5

    IntType1 i4 = 5;
    io:println(t[i4]); // @output 40.5
}

Test-Case: output
Description: Test the result of evaluating a member access expression when basic type of the evaluated value of the
             container expression is a tuple.
Labels: member-access-expr, module-type-decl, tuple-type, int, string, boolean, float, map-type, record-type,
        union-type, list-constructor-expr, mapping-constructor-expr

type Record record {|
    int a;
    string b;
|};

function init() {
    [int, string, string|boolean, map<int>, Record, float...] t = [10, "ABC", true, {x: 1, y: 2}, {a: 1, b: "CDE"}, 40.5, 30.5];

    io:println(t[0]); // @output 10
    io:println(t[1]); // @output ABC
    io:println(t[2]); // @output true
    io:println(t[3]); // @output {"x":1,"y":2}
    io:println(t[4]); // @output {"a":1,"b":"CDE"}
    io:println(t[5]); // @output 40.5
    io:println(t[6]); // @output 30.5
}

Test-Case: panic
Description: Test the result of evaluating a member access expression when the evaluated value(k) of the
             key expression is less than 0 with container expression whose basic type is a tuple (k < 0).
Labels: member-access-expr, tuple-type, int, string, float, list-constructor-expr, unary-minus, additive-expr

function init() {
    [int, string, float...] t = [10, "ABC", 10.5, 20.5, 30.5, 40.5];

    io:println(t[-1-2]); // @panic index out of range
}

Test-Case: panic
Description: Test the result of evaluating a member access expression when the evaluated value(k) of the
             key expression is equal to the length of the evaluated value(c) of the
             container expression whose basic type is a tuple (k = length(c)).
Labels: member-access-expr, tuple-type, int, string, float, list-constructor-expr

function init() {
    [int, string, float...] t = [10, "ABC", 10.5, 20.5, 30.5, 40.5];

    io:println(t[6]); // @panic index out of range
}

Test-Case: panic
Description: Test the result of evaluating a member access expression when the evaluated value(k) of the
             key expression is greater than the length of the evaluated value(c) of the
             container expression whose basic type is a tuple (k > length(c)).
Labels: member-access-expr, tuple-type, int, string, float, list-constructor-expr

function init() {
    [int, string, float...] t = [10, "ABC", 10.5, 20.5, 30.5, 40.5];

    io:println(t[10]); // @panic index out of range
}

Test-Case: output
Description: Test the static type of member access expression when the container expression is of basic type list.
Labels: member-access-expr, module-type-decl, tuple-type, int, string, boolean, float, map-type, record-type,
        union-type, optional-type, list-constructor-expr, mapping-constructor-expr

type Record record {|
    int a;
    string b;
|};

function init() {
    [int, string|decimal, boolean?, map<int>, Record, float...] t = [10, "ABC", true, {x: 1, y: 2}, {a: 1, b: "CDE"}, 40.5, 30.5];

    int i0 = t[0];
    io:println(i0); // @output 10

    string|decimal i1 = t[1];
    io:println(i1); // @output ABC

    boolean? i3 = t[2];
    io:println(i3); // @output true

    map<int> i4 = t[3];
    io:println(i4); // @output {"x":1,"y":2}

    Record i5 = t[4];
    io:println(i5); // @output {"a":1,"b":"CDE"}

    float i6 = t[5];
    io:println(i6); // @output 40.5

    float i7 = t[6];
    io:println(i7); // @output 30.5
}

Test-Case: output
Description: Test field access expression as container expression of basic type list.
Labels: member-access-expr, tuple-type, int, string, list-constructor-expr, field-access-expr, mapping-constructor-expr,
        record-type, module-type-decl

type Record record {|
    [int, string] f1;
|};

function init() {
    Record rec = {f1: [10, "CL"]};
    io:println(rec.f1[1]); // @output CL
}

Test-Case: output
Description: Test member access expression as container expression of basic type list.
Labels: member-access-expr, tuple-type, int, string, array-type, list-constructor-expr

function init() {
    [int, string][] t = [[10, "CL"], [20, "NY"]];
    io:println(t[1][1]); // @output NY
}

Test-Case: output
Description: Test function call expression as container expression of basic type list.
Labels: member-access-expr, function-call-expr, tuple-type, int, string, list-constructor-expr

function init() {
    io:println(getTuple()[1]); // @output CL
}

function getTuple() returns [int, string] {
    return [10, "CL"];
}

Test-Case: output
Description: Test method call expression as container expression of basic type list.
Labels: member-access-expr, method-call-expr, module-class-defn, explicit-new-expr, tuple-type, int, string,
        list-constructor-expr

class Tuple {
    function getTuple() returns [int, string] {
        return [10, "CL"];
    }
}

function init() {
    Tuple t = new;
    io:println(t.getTuple()[1]); // @output CL
}

Test-Case: output
Description: Test let expression expression as container expression of basic type list.
Labels: member-access-expr, let-expr, tuple-type, int, string, list-constructor-expr

function init() {
    io:println((let [int, string] b = [10, "CL"] in b)[1]); // @output CL
}

Test-Case: output
Description: Test type cast expression as container expression of basic type list.
Labels: member-access-expr, optional-type, type-cast-expr, tuple-type, int, string, list-constructor-expr

function init() {
    [int, string]? t = [10, "CL"];
    io:println((<[int, string]> t)[1]); // @output CL
}

Test-Case: output
Description: Test conditional expression as container expression of basic type list.
Labels: member-access-expr, conditional-expr, tuple-type, int, string, list-constructor-expr, relational-expr

function init() {
    [int, string] t1 = [10, "CL"];
    [int, string] t2 = [20, "NY"];
    int x = 5;

    io:println((x < 5 ? t1 : t2)[1]); // @output NY
}

Test-Case: output
Description: Test checking expression as container expression of basic type list.
Labels: member-access-expr, check, checkpanic, error-type, tuple-type, int, string, list-constructor-expr, union-type

function init() returns error? {
    [int, string]|error t = [10, "CL"];

    io:println((check t)[1]); // @output CL
    io:println((checkpanic t)[1]); // @output CL
}

Test-Case: error
Description: Test key expression with invalid static type.
Labels: member-access-expr, tuple-type, int, list-constructor-expr, string

type SomeType "1"|"3";

const c = "1";

function errorFunction() {
    [int, string] t = [10, "CL"];

    _ = t["1"]; // @error expected a value of subtype int as key

    string a = "1";
    _ = t[a]; // @error expected a value of subtype int as key

    SomeType b = "1";
    _ = t[b]; // @error expected a value of subtype int as key

    _ = t[c]; // @error expected a value of subtype int as key
}

Test-Case: error
Description: Test assigning result of member access expression to an invalid type.
Labels: member-access-expr, tuple-type, int, string, list-constructor-expr

function errorFunction() {
    [int, string] t = [10, "CL"];

    string _ = t[0]; // @error expected string, found int

    int _ = t[1]; // @error expected int, found string
}

Test-Case: error
Description: Test using a value greater/less than the size of a tuple as the key.
Labels: member-access-expr, tuple-type, int, string, list-constructor-expr

function errorFunction() {
    [int, string] t = [10, "CL"];

    _ = t[2]; // @error list index out of range
    _ = t[-1]; // @error list index out of range
}

Test-Case: error
Description: Test accessing members of an invalid structure.
Labels: member-access-expr, tuple-type, int, string, list-constructor-expr, optional-type

function errorFunction() {
    [int, string]? t = [10, "CL"];

    _ = t[0]; // @error type [int,string]? does not support member access
}

Test-Case: error
Description: Test missing key expression in member access expression.
Labels: member-access-expr, tuple-type, int, string, list-constructor-expr

function errorFunction() {
    [int, string] t = [10, "CL"];

    _ = t[]; // @error missing key expression
}

Test-Case: error
Description: Test assigning an invalid value to member access expression.
Labels: member-access-expr, tuple-type, int, string, list-constructor-expr

function errorFunction() {
    [int, string] t = [10, "CL"];

    t[1] = 1; // @error expected string, found int
}
