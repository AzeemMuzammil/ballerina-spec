Test-Case: error
Description: Test table constructor expression without the table keyword and key specifier, parsed as list constructor.
Labels: table-constructor-expr, table-type, map-type, any, list-constructor-expr

function errorFunction() {
    table<map<any>> _ = []; // @error incompatible type: expected table, found empty list
}

Test-Case: parser-error
Description: Test table constructor expression with key specifier without the table keyword.
Fail-Issue: ballerina-platform/ballerina-lang#33042
Labels: table-constructor-expr, table-type, record-type, key-specifier

function errorFunction() {
    table<record {}> _ = key() []; // @error missing table keyword

    _ = key() []; // @error missing table keyword
}

Test-Case: parser-error
Description: Test table constructor expression without/with incomplete brackets for members.
Labels: table-constructor-expr, table-type, record-type, key-specifier

function errorFunction() {
    table<record {}> _ = table; // @error missing open and close brackets
    table<record {}> _ = table key(); // @error missing open and close brackets
    table<record {}> _ = table [; // @error missing close bracket
    table<record {}> _ = table ]; // @error missing open bracket
    table<record {}> _ = table key() [; // @error missing close bracket
    table<record {}> _ = table key() ]; // @error missing open bracket
}

Test-Case: parser-error
Description: Test table constructor expression row list missing commas.
Labels: table-constructor-expr, table-type, record-type, key-specifier, mapping-constructor-expr

function errorFunction() {
    table<record {}> _ = table [
        {}
        {}  // @error missing comma 
    ];
    table<record {}> _ = table key() [
        {}
        {}  // @error missing comma
        {}  // @error missing comma
    ];
}

Test-Case: parser-error
Description: Test table constructor expression row list with incomplete mapping constructors.
Labels: table-constructor-expr, table-type, record-type, key-specifier, mapping-constructor-expr

function errorFunction() {
    record {} x = {};

    table<record {}> _ = table [
        {a: }, // @error missing value expression
        { // @error missing close brace
    ];

    table<record {}> _ = table key() [
        }  // @error expected a mapping constructor expression
    ];
}

Test-Case: parser-error
Description: Test table constructor expression row list having expressions that are not mapping constructors.
Labels: table-constructor-expr, table-type, record-type, key-specifier, mapping-constructor-expr

function errorFunction() {
    record {} x = {};

    table<record {}> _ = table [
        {},
        x // @error expected a mapping constructor expression
    ];

    table<record {}> _ = table key() [
        x,  // @error expected a mapping constructor expression
        fn(),  // @error expected a mapping constructor expression
        x  // @error expected a mapping constructor expression
    ];
}

function fn() returns record {} {
    return {};
}

Test-Case: output
Description: Test table constructor expression with no key-specifier, when there is a single applicable contextually-expected type, and no rows.
Labels: table-constructor-expr, table-type, record-type, int, string, module-type-defn, mapping-constructor-expr

type Employee record {
    int id;
    string name;
};

type Person record {
    int id?;
    string name;
};

function init() {
    table<Person> t = table [
    ];

    io:println(t.length()); // @output 0
    io:println(t is table<Person>); // @output true
    io:println(t is table<Employee>); // @output false
}

Test-Case: output
Description: Test table constructor expression with no key-specifier, when there is a single applicable contextually-expected type.
Labels: table-constructor-expr, table-type, record-type, int, string, module-type-defn, mapping-constructor-expr, is-expr

type Employee record {
    int id;
    string name;
};

type Person record {
    int id?;
    string name;
};

function init() {
    table<Person> t1 = table [
        {id: 1, name: "Jo"}
    ];

    io:println(t1.length()); // @output 1
    io:println(t1 is table<Person>); // @output true
    io:println(t1 is table<Employee>); // @output false

    table<Person> t2 = table [
        {id: 1, name: "Jo"},
        {id: 2, name: "May"}
    ];

    io:println(t2.length()); // @output 2
    io:println(t2 is table<Person>); // @output true
    io:println(t2 is table<Employee>); // @output false
}

Test-Case: output
Description: Test inherent type of member for table constructor expression with no key-specifier, when there is a single applicable contextually-expected type.
Labels: table-constructor-expr, table-type, record-type, int, string, module-type-defn, mapping-constructor-expr, is-expr, foreach-stmt, iterable-table

type Employee record {
    int id;
    string name;
};

type Person record {
    int id?;
    string name;
};

function init() {
    table<Person> t1 = table [
        {id: 1, name: "Jo"}
    ];

    foreach Person p in t1 {
        io:println(p is Person); // @output true
        io:println(p is Employee); // @output false
    }

    table<Person> t2 = table [
        {id: 1, name: "Jo"},
        {id: 2, name: "May"}
    ];

    foreach Person p in t2 {
        io:println(p is Person); // @output true
                                 // @output true
    }

    foreach Person p in t2 {
        io:println(p is Employee); // @output false
                                   // @output false
    }
}

Test-Case: error
Description: Test incompatible members in table constructor expressions with no key-specifier, when there is a single applicable contextually-expected type.
Fail-Issue: ballerina-platform/ballerina-lang#33049
Labels: table-constructor-expr, table-type, int, string, record-type, module-type-defn, mapping-constructor-expr, boolean-literal

type Employee record {
    int id;
    string name;
};

function errorFunction() {
    table<Employee> t1 = table [
        {id: 1, name: "Jo"},
        {id: 1}, // @error missing non-defaultable required field 'name'
        {id: 1, name: true} // @error expected value of type string for the 'name' field
    ];
}

Test-Case: error
Description: Test incompatible members in table constructor expressions with no key-specifier, when the mapping constructor has variable-name, computed-name, and spread fields
Fail-Issue: ballerina-platform/ballerina-lang#33049
Labels: table-constructor-expr, table-type, int, string, record-type, module-type-defn, mapping-constructor-expr, boolean-literal

type Employee record {|
    int id;
    string name;
|};

function errorFunction() {
    string st = "name";

    record {|int id;|} r1 = {id: 6};
    record {|int id; int name;|} r2 = {id: 7, name: 0};

    string id = "not an int";

    table<Employee> _ = table [
        {id: 1, name: "Jo"},
        {id: 2, name: "Amy", [st]: true}, // @error expected an int|string field with the computed key, found boolean
        {id: 3, [st]: 2}, // @error missing non-defaultable required field 'name'
        {id: 4, name: true}, // @error expected value of type string for the 'name' field
        {id, name: "Alex"}, // @error expected value of type int for the 'id' field
        {...r1}, // @error missing non-defaultable required record field 'name'
        {...r2} // @error expected value of type string for the 'name' field
    ];
}

Test-Case: output
Description: Test inherent type of member for table constructor expression with no key-specifier, when the applicable contextually-expected type is a union.
Fail-Issue: ballerina-platform/ballerina-spec#962
Labels: table-constructor-expr, table-type, record-type, int, string, module-type-defn, mapping-constructor-expr, is-expr, foreach-stmt, iterable-table, union-type

type Employee record {
    int id;
    string name;
};

type Person record {
    int id?;
    string name;
};

function init() {
    table<Person>|table<Employee> t1 = table [
        {name: "Jo"},
        {name: "May", id: 2}
    ];

    table<record {}> t2 = t1;

    foreach record {} p in t2 {
        io:println(p is Person); // @output true
                                 // @output true
    }

    foreach record {} p in t2 {
        io:println(p is Employee); // @output false
                                   // @output false
    }
}

Test-Case: error
Description: Test table constructor expression with no key-specifier, when the applicable contextually-expected type is a union and there is no compatible type.
Labels: table-constructor-expr, table-type, record-type, int, string, module-type-defn, mapping-constructor-expr, union-type

type Employee record {
    int id;
    string name;
};

type Person record {
    int id?;
    string name;
};

function errorFunction() {
    table<Person>|table<Employee> t1 = table [ // @error incompatible table constructor expression for expected type table<Person>|table<Employee>
        {name: "Jo"},
        {id: "abc"}
    ];
}

Test-Case: error
Description: Test table constructor expression with no key-specifier, when the applicable contextually-expected type is a union and the type is ambiguous with rows.
Labels: table-constructor-expr, table-type, record-type, int, string, module-type-defn, mapping-constructor-expr, union-type

type Employee record {
    int id;
    string name;
};

type Person record {
    int id?;
    string name;
};

function errorFunction() {
    table<Person>|table<Employee> t1 = table [ // @error ambiguous type '(table<Person>|table<Employee>)'
        {id: 1, name: "Jo"},
        {id: 2, name: "Amy"}
    ];
}

Test-Case: output
Description: Test table constructor expression with no key-specifier, when the contextually-expected type is a union including non-table types.
Labels: table-constructor-expr, table-type, record-type, int, string, module-type-defn, mapping-constructor-expr, type-cast-expr

type Employee record {
    int id;
    string name;
};

type Person record {
    int id?;
    string name;
};

function init() {
    Employee|table<Person> t = table [
        {name: "Jo"}
    ];

    io:println((<table<Person>> t).length()); // @output 1
    io:println(t is table<Person>); // @output true
    io:println(t is table<Employee>); // @output false
}

Test-Case: output
Description: Test when there is no contextually-expected type the member type of the inherent type being derived from the the static type of the expressions for the members, for a table constructor expression with no key-specifier. The member type will be the smallest record type that is a supertype of the static types of all the expressions in the row-list.
             Test for when all the members are of the same type.
Labels: table-constructor-expr, table-type, record-type, string, mapping-constructor-expr, var

function init() {
    var v1 = table [
        {name: "Jo"}
    ];
    table<record {|string name;|}> t1 = v1;
    table<record {}> t = t1;

    io:println(v1.length()); // @output 1
    io:println(t is table<record {|string name;|}>); // @output true

    var v2 = table [
        {name: "Jo"},
        {name: "Amy"}
    ];
    table<record {|string name;|}> t2 = v2;
    t = t2;

    io:println(v2.length()); // @output 2
    io:println(t is table<record {|string name;|}>); // @output true
}

Test-Case: output
Description: Test when there is no contextually-expected type the member type of the inherent type being derived from the the static type of the expressions for the members, for a table constructor expression with no key-specifier. The member type will be the smallest record type that is a supertype of the static types of all the expressions in the row-list.
             Test for when members are of different types.
Labels: table-constructor-expr, table-type, record-type, int, string, boolean, mapping-constructor-expr, var

function init() {
    var v1 = table [
        {name: "Jo"},
        {id: 3},
        {employed: true}
    ];
    table<record {|string name?; int id?; boolean employed?;|}> t1 = v1;
    table<record {}> t = t1;

    io:println(v1.length()); // @output 3
    io:println(t is table<record {|string name?; int id?; boolean employed?;|}>); // @output true
    io:println(t is table<record {|string name; int id; boolean employed;|}>); // @output false
}

Test-Case: output
Description: Test when there is no contextually-expected type the member type of the inherent type being derived from the the static type of the expressions for the members, for a table constructor expression with no key-specifier. The member type will be the smallest record type that is a supertype of the static types of all the expressions in the row-list.
             Test for when members are of different types and the mapping constructor has variable-name fields.
Labels: table-constructor-expr, table-type, record-type, int, string, mapping-constructor-expr, var

function init() {
    int id = 2;
    boolean employed = false;

    var v1 = table [
        {name: "Jo"},
        {id},
        {employed}
    ];
    table<record {|string name?; int id?; boolean employed?;|}> t1 = v1;
    table<record {}> t = t1;

    io:println(v1.length()); // @output 3
    io:println(t is table<record {|string name?; int id?; boolean employed?;|}>); // @output true
    io:println(t is table<record {|string name; int id; boolean employed;|}>); // @output false
}

Test-Case: output
Description: Test when there is no contextually-expected type the member type of the inherent type being derived from the the static type of the expressions for the members, for a table constructor expression with no key-specifier. The member type will be the smallest record type that is a supertype of the static types of all the expressions in the row-list.
             Test for when members are of different types and the mapping constructor has computed-name fields.
Labels: table-constructor-expr, table-type, record-type, int, boolean, string, mapping-constructor-expr, var

function init() {
    string s1 = "id";
    string s2 = "employed";

    var v1 = table [
        {name: "Jo"},
        {[s1]: 2},
        {[s2]: false}
    ];
    table<record {|int|boolean|string name?; int|boolean...;|}> t1 = v1;
    table<record {}> t = t1;

    io:println(v1.length()); // @output 3
    io:println(t is table<record {|int|boolean|string name?; int|boolean...;|}>); // @output true
    io:println(t is table<record {|int|boolean|string name; int id; boolean employed;|}>); // @output false
}

Test-Case: output
Description: Test when there is no contextually-expected type the member type of the inherent type being derived from the the static type of the expressions for the members, for a table constructor expression with no key-specifier. The member type will be the smallest record type that is a supertype of the static types of all the expressions in the row-list.
             Test for when members are of different types and the mapping constructor has a map spread field.
Labels: table-constructor-expr, table-type, record-type, int, boolean, string, mapping-constructor-expr, var

function init() {
    map<int> m = {a: 1, b: 2};

    var v1 = table [
        {name: "Jo"},
        {...m}
    ];
    table<record {|string|int name?; int...;|}> t1 = v1;
    table<record {}> t = t1;

    io:println(v1.length()); // @output 2
    io:println(t is table<record {|string|int name?; int...;|}>); // @output true
    io:println(t is table<record {|string name; int...;|}>); // @output false
}

Test-Case: output
Description: Test when there is no contextually-expected type the member type of the inherent type being derived from the the static type of the expressions for the members, for a table constructor expression with no key-specifier. The member type will be the smallest record type that is a supertype of the static types of all the expressions in the row-list.
             Test for when members are of different types and the mapping constructor has a record spread field.
Labels: table-constructor-expr, table-type, record-type, int, boolean, string, mapping-constructor-expr, var

function init() {
    record {|int a; int b?; int c?;|} m = {a: 1, b: 2};

    var v1 = table [
        {name: "Jo"},
        {...m}
    ];
    table<record {|string name?; int a?; int b?; int c?;|}> t1 = v1;
    table<record {}> t = t1;

    io:println(v1.length()); // @output 2
    io:println(t is table<record {|string name?; int a?; int b?; int c?;|}>); // @output true
    io:println(t is table<record {|string name; int a; int b; int c?;|}>); // @output false
}

Test-Case: output
Description: Test when there is no contextually-expected type the member type of the inherent type being derived from the the static type of the expressions for the members, for a table constructor expression with no key-specifier. The member type will be the smallest record type that is a supertype of the static types of all the expressions in the row-list.
             Test for when members are of different types and the mapping constructor has a record spread field with never-typed fields.
Labels: table-constructor-expr, table-type, record-type, int, string, mapping-constructor-expr, var

function init() {
    record {int a; int b?; int c?; never name?;} m = {a: 1, b: 2};

    var v1 = table [
        {name: "Jo"},
        {...m}
    ];
    table<record {string name?; int a?; int b?; int c?;}> t1 = v1;
    table<record {}> t = t1;

    io:println(v1.length()); // @output 2
    io:println(t is table<record {string name?; int a?; int b?; int c?;}>); // @output true
    io:println(t is table<record {string name?; int a; int b; int c?;}>); // @output false
}

Test-Case: output
Description: Test when there is no contextually-expected type the member type of the inherent type being derived from the the static type of the expressions for the members, for a table constructor expression with no key-specifier. The member type will be the smallest record type that is a supertype of the static types of all the expressions in the row-list.
             Test for when members are of types that share fields with the same name.
Labels: table-constructor-expr, table-type, record-type, int, string, mapping-constructor-expr, var

function init() {
    var v1 = table [
        {a: 1},
        {a: "str", b: 2}
    ];
    table<record {|string|int a; int b?;|}> t1 = v1;
    table<record {}> t = t1;

    io:println(v1.length()); // @output 2
    io:println(t is table<record {|string|int a; int b?;|}>); // @output true
    io:println(t is table<record {|string|int a; int b;|}>); // @output false
}

Test-Case: output
Description: Test when there is no contextually-expected type the member type of the inherent type being derived from the the static type of the expressions for the members, for a table constructor expression with no key-specifier. The member type will be the smallest record type that is a supertype of the static types of all the expressions in the row-list.
             Test for when members are of types that share fields with the same name, and have computed-field names and spread fields.
Labels: table-constructor-expr, table-type, record-type, int, string, mapping-constructor-expr, var

function init() {
    record {string a; int b?;} m = {a: "str", b: 2};
    string s1 = "a";
    string s2 = "b";

    var v1 = table [
        {a: 1},
        {...m},
        {[s1]: true, c: 2, [s2]: false}
    ];
    table<record {int|string|boolean a?; int|boolean b?; anydata c?;}> t1 = v1;
    table<record {}> t = t1;

    io:println(v1.length()); // @output 3
    io:println(t is table<record {int|string|boolean a?; int|boolean b?; anydata c?;}>); // @output true
    io:println(t is table<record {int|string|boolean a?; int|string b?; anydata c?;}>); // @output false
    io:println(t is table<record {int a?; int|string b?; anydata c?;}>); // @output false
}

Test-Case: error
Description: Test the derived type for a table constructor expression with no key-specifier via invalid assignment.
             Test for when all the members are of the same type.
Labels: table-constructor-expr, table-type, record-type, int, string, mapping-constructor-expr, var

function errorFunction() {
    var v1 = table [
        {name: "Jo"}
    ];
    table<record {|int name;|}> _ = v1; // @error expected 'table<record {| int name; |}>', found 'table<record {| string name; |}>'

    var v2 = table [
        {name: "Jo"},
        {name: "Amy"}
    ];
    table<record {|string name; int? id;|}> _ = v2; // @error expected 'table<record {| string name; int? id; |}>', found 'table<record {| string name; |}>'
}

Test-Case: error
Description: Test the derived type for a table constructor expression with no key-specifier via invalid assignment.
             Test for when members are of different types.
Labels: table-constructor-expr, table-type, record-type, int, string, module-type-defn, mapping-constructor-expr, type-cast-expr, var

function errorFunction() {
    var v1 = table [
        {name: "Jo"},
        {id: 3},
        {employed: true}
    ];
    table<record {|string name?; int id; boolean employed;|}> _ = v1; // @error expected 'table<record {| string name?; int id; boolean employed; |}>', found 'table<record {| string name?; int id?; boolean employed?; |}>'
    table<record {|string name; int id; boolean employed;|}> _ = v1; // @error expected 'table<record {| string name; int id; boolean employed; |}>', found 'table<record {| string name?; int id?; boolean employed?; |}>'
}

Test-Case: error
Description: Test the derived type for a table constructor expression with no key-specifier via invalid assignment.
             Test for when members are of different types and the mapping constructor has variable-name fields.
Labels: table-constructor-expr, table-type, record-type, int, string, mapping-constructor-expr, var

function errorFunction() {
    int id = 2;
    boolean employed = false;

    var v1 = table [
        {name: "Jo"},
        {id},
        {employed}
    ];
    table<record {|string nam?; int id?; boolean employed?;|}> _ = v1; // @error expected 'table<record {| string nam?; int id?; boolean employed?; |}>', found 'table<record {| string name?; int id?; boolean employed?; |}>'
}

Test-Case: error
Description: Test the derived type for a table constructor expression with no key-specifier via invalid assignment.
             Test for when members are of different types and the mapping constructor has computed-name fields.
Labels: table-constructor-expr, table-type, record-type, int, boolean, string, mapping-constructor-expr, var

function errorFunction() {
    string s1 = "id";
    string s2 = "employed";

    var v1 = table [
        {name: "Jo"},
        {[s1]: 2},
        {[s2]: false}
    ];
    table<record {|string name?; int|boolean...;|}> _ = v1; // @error expected table<record {|string name?; int|boolean...;|}>, found table<record {|string|int|boolean name?; int|boolean...;|}>
}

Test-Case: error
Description: Test the derived type for a table constructor expression with no key-specifier via invalid assignment.
             Test for when members are of different types and the mapping constructor has a map spread field.
Labels: table-constructor-expr, table-type, record-type, int, boolean, string, mapping-constructor-expr, var

function errorFunction() {
    map<int> m = {a: 1, b: 2};

    var v1 = table [
        {name: "Jo"},
        {...m}
    ];
    table<record {|string name?;|}> _ = v1; // @error expected 'table<record {|string name?;|}>', found 'table<record {|int|string name?; int...;|}>'
    table<record {|string|int name?;|}> _ = v1; // @error expected 'table<record {|string|int name?;|}>', found 'table<record {|int|string name?; int...;|}>'
    table<record {|string name?; int...;|}> _ = v1; // @error expected 'table<record {|string name?; int...;|}>', found 'table<record {|int|string name?; int...;|}>'
}

Test-Case: error
Description: Test the derived type for a table constructor expression with no key-specifier via invalid assignment.
             Test for when members are of different types and the mapping constructor has a record spread field.
Labels: table-constructor-expr, table-type, record-type, int, boolean, string, mapping-constructor-expr, var

function errorFunction() {
    record {|int a; int b?; int c?;|} m = {a: 1, b: 2};

    var v1 = table [
        {name: "Jo"},
        {...m}
    ];
    table<record {|string name; int a?; int b?; int c?;|}> _ = v1; // @error expected 'table<record {| string name; int a?; int b?; int c?; |}>', found 'table<record {| string name?; int a?; int b?; int c?; |}>'
    table<record {|string name?; int a?; int b?;|}> _ = v1; // @error expected 'table<record {| string name?; int a?; int b?; |}>', found 'table<record {| string name?; int a?; int b?; int c?; |}>'
}

Test-Case: error
Description: Test the derived type for a table constructor expression with no key-specifier via invalid assignment.
             Test for when members are of different types and the mapping constructor has a record spread field with never-typed fields.
Labels: table-constructor-expr, table-type, record-type, int, string, mapping-constructor-expr, var

function errorFunction() {
    record {int a; int b?; int c?; never name?;} m = {a: 1, b: 2};

    var v1 = table [
        {name: "Jo"},
        {...m}
    ];
    table<record {string name; int a?; int b?; int c?;}> _ = v1; // @error expected 'table<record {string name; int a?; int b?; int c?;}>', found 'table<record {string name?; int a?; int b?; int c?;}>'
}

Test-Case: error
Description: Test the derived type for a table constructor expression with no key-specifier via invalid assignment.
             Test for when members are of types that share fields with the same name.
Labels: table-constructor-expr, table-type, record-type, int, string, mapping-constructor-expr, var

function errorFunction() {
    var v1 = table [
        {a: 1},
        {a: "str", b: 2}
    ];
    table<record {|int a; int b?;|}> _ = v1; // @error expected 'table<record {| int a; int b?; |}>', found 'table<record {| (int|string) a; int b?; |}>'
}

Test-Case: error
Description: Test the derived type for a table constructor expression with no key-specifier via invalid assignment.
             Test for when members are of types that share fields with the same name, and have computed-field names and spread fields.
Labels: table-constructor-expr, table-type, record-type, int, string, mapping-constructor-expr, var

function errorFunction() {
    record {string a; int b?;} m = {a: "str", b: 2};
    string s1 = "a";
    string s2 = "b";

    var v1 = table [
        {a: 1},
        {...m},
        {[s1]: true, c: 2, [s2]: false}
    ];
    table<record {int|string|boolean a?; int|string b?; int c?;}> _ = v1; // @error expected 'table<record { (int|string|boolean) a?; (int|string) b?; int c?; }>', found 'table<record { (int|string|boolean) a?; (int|string) b?; anydata c?; }>'
}

Test-Case: error
Description: Test error for table constructor expression with no key-specifier with an empty row list and no contextually-expected type.
Labels: table-constructor-expr, mapping-constructor-expr, var

function errorFunction() {
    var _ = table []; // @error a table constructor expression cannot have an empty row list when there is no contextually-expected type
}

Test-Case: error
Description: Test non-const variable-name field for key field in table constructor without a key sequence when the key sequence is present in the applicable contextually-expected type.
Fail-Issue: ballerina-platform/ballerina-lang#33049
Labels: table-constructor-expr, mapping-constructor-expr, table-type

function errorFunction() {
    int id = 1;

    table<record {readonly int id; string name;}> key (id) _ = table [
        {id, name: "Jo"}, // @error id is not a const-expr
        {id: 1, name: "Amy"},
        {id: 2, name: "Amy"}, 
        {id, name: "Alex"} // @error id is not a const-expr
    ];
}

Test-Case: error
Description: Test non-const spread-expr field for key field in table constructor without a key sequence when the key sequence is present in the applicable contextually-expected type.
Fail-Issue: ballerina-platform/ballerina-lang#33049
Labels: table-constructor-expr, mapping-constructor-expr, table-type

function errorFunction() {
    record {|int id;|} r = {id: 1234};

    table<record {readonly int id; string name;}> key (id) _ = table [
        {...r, name: "Jo"}, // @error id via spread field is not a const-expr
        {name: "Jo", ...r} // @error id via spread field is not a const-expr
    ];
}


