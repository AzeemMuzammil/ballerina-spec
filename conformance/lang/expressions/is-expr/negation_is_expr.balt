Test-Case: output
Description: Test nil literal as expression in type test expression.
Labels: is-expr, boolean, nil-literal, nil-type

function init() {
    boolean b = () !is ();
    io:println(b); // @output false
}

Test-Case: output
Description: Test int literal as expression in type test expression.
Labels: is-expr, boolean, DecimalNumber, int

function init() {
    boolean b = 12 !is int;
    io:println(b); // @output false
}

Test-Case: output
Description: Test floating point literal as expression in type test expression.
Labels: is-expr, boolean, DecimalFloatingPointNumber, float

function init() {
    boolean b = 12.5 !is float;
    io:println(b); // @output false
}

Test-Case: output
Description: Test floating point literal as expression in type test expression.
Labels: is-expr, boolean, boolean-literal

function init() {
    boolean b = true !is boolean;
    io:println(b); // @output false
}

Test-Case: output
Description: Test string literal as expression in type test expression.
Labels: is-expr, boolean, string, string-literal

function init() {
    boolean b = "A" !is string;
    io:println(b); // @output false
}

Test-Case: output
Description: Test byte array literal as expression in type test expression.
Labels: is-expr, boolean, byte-array-literal, array-type, byte

function init() {
    boolean b = base64 `aGVsbG8gYmFsbGVyaW5hICEhIQ==` !is byte[];
    io:println(b); // @output false
}

Test-Case: output
Description: Test string template expression as expression in type test expression.
Labels: is-expr, boolean, string-template-expr, string

function init() {
    boolean b = string `ABC` !is string;
    io:println(b); // @output false
}

Test-Case: output
Description: Test xml template expression as expression in type test expression.
Labels: is-expr, boolean, xml, xml:Text, xml:Element

function init() {
    boolean b1 = xml `ABC` !is xml;
    io:println(b1); // @output false

    boolean b2 = xml `ABC` !is xml:Text;
    io:println(b2); // @output false

    boolean b3 = xml `<name>Enid Blyton</name><!--Text-->` !is xml:Element;
    io:println(b3); // @output true
}

Test-Case: output
Description: Test list constructor expression as expression in type test expression.
Labels: is-expr, boolean, list-constructor-expr, array-type, tuple-type, int

function init() {
    boolean b1 = [1, 2, 3] !is int[];
    io:println(b1); // @output false

    boolean b2 = [1, 2, 3] !is int[3];
    io:println(b2); // @output false

    boolean b3 = [1, 2, 3] !is [int, int, int];
    io:println(b3); // @output false

    boolean b4 = [1, 2, 3] !is [int...];
    io:println(b4); // @output false

    boolean b5 = [1, 2, 3] !is [int, int...];
    io:println(b5); // @output false

    boolean b6 = [1, 2, 3] !is [int, int, int...];
    io:println(b6); // @output false

    boolean b7 = [1, 2, 3] !is [int, int, int, int...];
    io:println(b7); // @output false
}

Test-Case: output
Description: Test list constructor expression as expression in type test expression.
Labels: is-expr, boolean, list-constructor-expr, array-type, tuple-type, int, string, float, record-type, map-type,
        union-type, any

function init() {
    boolean b1 = [1, "ABC", 10.2, {a: 2}] !is any;
    io:println(b1); // @output false

    boolean b2 = [1, "ABC", 10.2, {a: 2}] !is [int, string, float, record {|int a;|}];
    io:println(b2); // @output false

    boolean b3 = [1, "ABC", 10.2, {a: 2}] !is [int, string, float, map<int>];
    io:println(b3); // @output false

    boolean b4 = [1, "ABC", 10.2, {a: 2}] !is [int, string, float|map<int>...];
    io:println(b4); // @output false

    boolean b5 = [1, "ABC", 10.2, {a: 2}] !is (int|string|float|record {|int a;|})[];
    io:println(b5); // @output false

    boolean b6 = [1, "ABC", 10.2, {a: 2}] !is (int|string|float|map<int>)[4];
    io:println(b6); // @output false
}

Test-Case: output
Description: Test mapping constructor expression as expression in type test expression.
Labels: is-expr, boolean, mapping-constructor-expr, map-type, record-type, any, anydata, int, string, float,
        union-type, rest-type, error-type

function init() {
    boolean b1 = {a: 1, b: 2, "c": 3} !is anydata;
    io:println(b1); // @output false

    boolean b2 = {a: 1, b: 2, "c": 3} !is map<int>;
    io:println(b2); // @output false

    boolean b3 = {a: 1, b: "ABC", "c": 10f} !is record {|int a; string b; float c;|};
    io:println(b3); // @output false

    boolean b4 = {a: 1, b: "ABC", "c": 10f} !is record {|int a; string b; float...;|};
    io:println(b4); // @output false

    boolean b5 = {a: 1, b: "ABC", "c": 10f} !is map<int|string|float>;
    io:println(b5); // @output false

    boolean b6 = {a: 1, b: 2, "c": error("Error")} !is any;
    io:println(b6); // @output false

    boolean b7 = {a: 1, b: "ABC", "c": 10f} !is record {|readonly int a; readonly string b; float...;|};
    io:println(b7); // @output true
}

Test-Case: output
Description: Test table constructor expression as expression in type test expression.
Labels: is-expr, boolean, table-constructor-expr, anydata, any, record-type, map-type

function init() {
    boolean b1 = table [{a: 1, b: 2, "c": 3}] !is anydata;
    io:println(b1); // @output false

    boolean b2 = table [{a: 1, b: "ABC", "c": 10f, "d": error("Err")}] !is any;
    io:println(b2); // @output false

    boolean b3 = table [{a: 1, b: "ABC", "c": 10f, "d": error("Err")}] !is table<record {|int a; string b; float c; error d;|}>;
    io:println(b3); // @output false

    boolean b4 = table [{a: 1, b: "ABC", "c": 10f}] !is table<record {|readonly int a; readonly string b; float c;|}> key(a, b);
    io:println(b4); // @output true

    boolean b5 = table key(a, b) [{a: 1, b: "ABC", "c": 10f}] !is table<record {|readonly int a; readonly string b; float c;|}> key(a, b);
    io:println(b5); // @output false

    boolean b6 = table key(a, b) [{a: 1, b: "ABC", "c": 10f}] !is table<record {|int a; string b; float c;|}>;
    io:println(b6); // @output false

    boolean b7 = table [{a: 1, b: "ABC", "c": 10f}] !is table<map<int|string|float>>;
    io:println(b7); // @output false
}

Test-Case: output
Description: Test table constructor expression as expression in type test expression.
Fail-Issue: ballerina-platform/ballerina-lang#35126
Labels: is-expr, boolean, table-constructor-expr, anydata, any, record-type, map-type

function init() {
    boolean b8 = table key(a, b) [{a: 1, b: "ABC", "c": 10f}] !is table<map<int|string|float>>;
    io:println(b8); // @output true
}

Test-Case: output
Description: Test object constructor expression as expression in type test expression.
Labels: is-expr, boolean, module-type-decl, object-type, object-constructor-expr

type Client client object {
    int a;
    function f1();
    remote function f2();
};

type Service service object {
    int a;
    function f1();
    function f2();
};

function init() {
    boolean b1 = object {} !is object {};
    io:println(b1); // @output false

    boolean b2 = object {
        int a = 1;
        isolated function f1() {
        }
        function f2() {
        }
    } !is object {
        int a;
        function f1();
        function f2();
    };
    io:println(b2); // @output false

    boolean b3 = client object {
        int a = 1;
        isolated function f1() {
        }
        remote function f2() {
        }
    } !is client object {
        int a;
        function f1();
        remote function f2();
    };
    io:println(b3); // @output false

    boolean b4 = client object {
        int a = 1;
        isolated function f1() {
        }
        remote function f2() {
        }
    } !is Client;
    io:println(b4); // @output false

    boolean b5 = client object {
        int a = 1;
        string b = "ABC";
        isolated function f1() {
        }
        remote function f2() {
        }
        private function f3() {
        }
    } !is Client;
    io:println(b5); // @output false

    boolean b6 = service object {
        int a = 1;
        string b = "ABC";
        isolated function f1() {
        }
        function f2() {
        }
        private function f3() {
        }
    } !is Service;
    io:println(b6); // @output false
}

Test-Case: output
Description: Test new expression as expression in type test expression.
Labels: is-expr, boolean, explicit-new-expr, module-class-defn, object-type

class Class {
    function f1() returns int {
        return 60;
    }
}

type Object1 object {
    function f1() returns int;
};

type Object2 object {
    int a;
    function f1() returns int;
};

function init() {
    boolean b1 = new Class() !is object {};
    io:println(b1); // @output false

    boolean b2 = new Class() !is object {
        function f1() returns int;
    };
    io:println(b2); // @output false

    boolean b3 = new Class() !is Object1;
    io:println(b3); // @output false

    boolean b4 = new Class() !is Object2;
    io:println(b4); // @output true

    boolean b5 = new Class() !is object {
        int a;
        function f1() returns int;
    };
    io:println(b5); // @output true

    boolean b6 = new Class() !is isolated object {
        function f1() returns int;
    };
    io:println(b6); // @output false
}

Test-Case: output
Description: Test variable reference expression as expression in type test expression.
Labels: is-expr, variable-reference-expr, int, string, error, union-type, map-type, any, anydata,
        table-type, record-type, mapping-constructor-expr, table-constructor-expr

function init() {
    int|string a = 10;
    io:println(a !is int); // @output false

    map<string|error> b = {a: "A", b: "B"};
    io:println(b !is map<any>); // @output true
    io:println(b !is any); // @output false
    io:println(b !is map<string>); // @output true

    table<record {|int a; string b;|}> c = table [{a: 1, b: "A"}];
    io:println(c !is table<record {|readonly int a; string b;|}>); // @output true
    io:println(c !is table<map<int|string>>); // @output false
    io:println(c !is anydata); // @output false
}

Test-Case: output
Description: Test field access expression as expression in type test expression.
Labels: is-expr, field-access-expr, module-type-decl, union-type, record-type, mapping-constructor-expr,
        int, float, string, boolean, optional-type

type Type string|xml|boolean;

type Record1 record {|
    int|string a;
    float? b;
    int c?;
    boolean d = true;
    Type? e;
    string...;
|};

type Record2 record {
    int|string a;
    float? b;
    int c?;
    boolean d = true;
};

function init() {
    Record1 rec1 = {a: 1, b: (), "e": "A", "f": "B"};

    io:println(rec1.a !is int); // @output false
    io:println(rec1.b !is float); // @output true
    io:println(rec1.c !is int); // @output true
    io:println(rec1.d !is Type); // @output false
    io:println(rec1.e !is string); // @output false

    Record2 rec2 = {a: 1, b: 2f, c: 1, d: false, "e": "A"};

    io:println(rec2.a !is int); // @output false
    io:println(rec2.b !is float); // @output false
    io:println(rec2.c !is int); // @output false
    io:println(rec2.d !is boolean); // @output false
}

Test-Case: output
Description: Test optional field access expression as expression in type test expression.
Labels: is-expr, optional-field-access-expr, module-type-decl, union-type, record-type,
        mapping-constructor-expr, int, float, string, boolean, optional-type

type Type string|xml|boolean;

type Record1 record {|
    int|string a;
    float? b;
    int c?;
    boolean d = true;
    Type? e;
    string...;
|};

type Record2 record {
    int|string a;
    float? b;
    int c?;
    boolean d = true;
};

function init() {
    Record1 rec1 = {a: 1, b: (), "e": "A", "f": "B"};

    io:println(rec1?.a !is int); // @output false
    io:println(rec1?.b !is float); // @output true
    io:println(rec1?.c !is int); // @output true
    io:println(rec1?.d !is Type); // @output false
    io:println(rec1?.e !is string); // @output false

    Record2 rec2 = {a: 1, b: 2f, c: 1, d: false, "e": "A"};

    io:println(rec2?.a !is int); // @output false
    io:println(rec2?.b !is float); // @output false
    io:println(rec2?.c !is int); // @output false
    io:println(rec2?.d !is boolean); // @output false
}

Test-Case: output
Description: Test xml attribute access expression as expression in type test expression.
Fail-Issue: ballerina-platform/ballerina-lang#33243
Labels: is-expr, xml-attribute-access-expr, string, error, union-type, module-type-decl, xmlns-decl-stmt,
        nil-type, optional-type

type Type1 string|error;

type Type2 string|error?;

type Type3 string;

xmlns "NS" as ns;

function init() {
    xml x1 = xml `<messages id="b">
                    <note id="1">
                        <to>John</to>
                    </note>
                    <note id="2">
                        <to>Anne</to>
                    </note>
                </messages>`;

    io:println(x1.id !is string); // @output false
    io:println(x1.id !is Type1); // @output false
    io:println(x1/<note>.id !is error); // @output false
    io:println(x1/<note>[1].id !is Type2); // @output false

    xml x2 = xml `<root ns:attr="attr-val"><a attr="a-attr"></a><b attr="b-attr"></b></root>`;
    io:println(x2/*.attr !is error); // @output false
    io:println(x2.ns:attr !is string); // @output false

    xml:Element x3 = xml `<elem xmlns="ns-uri" attr="val" xml:space="default"></elem>`;
    io:println(x3.attr !is string); // @output false
    io:println(x3.attrNon !is error); // @output false

    xml<xml:Element> x4 = xml `<elem xmlns="ns-uri" attr="val" xml:space="default"></elem>`;
    io:println(x4.attr !is string); // @output false
    io:println(x4?.attr !is string); // @output false
    io:println(x4.attrNon !is error); // @output false
    io:println(x4?.attrNon !is ()); // @output false
}

Test-Case: output
Description: Test xml attribute access expression as expression in type test expression.
Fail-Issue: ballerina-platform/ballerina-lang#35190
Labels: is-expr, xml:Element, xml-optional-attribute-access-expr, string, nil-type

function init() {
    xml:Element x3 = xml `<elem xmlns="ns-uri" attr="val" xml:space="default"></elem>`;
    io:println(x3?.attr !is string); // @output false
    io:println(x3?.attrNon !is ()); // @output false
}

Test-Case: output
Description: Test annotation access expression as expression in type test expression.
Fail-Issue: ballerina-platform/ballerina-lang#33243
Labels: is-expr, annot-access-expr, module-type-decl, record-type, mapping-constrcutor-expr, annotation-decl,
        module-class-decl, explicit-new-expr, typeof-expr, typedesc-type, any, array-type

type Annot record {
    string foo;
    int bar?;
};

public annotation Annot v1 on type, class;

annotation Annot[] v2 on class;

public annotation Annot v3 on function;

@v1 {
    foo: "strValue",
    bar: 1
}
type T1 record {
    string name;
};

@v1 {
    foo: "strValue"
}
@v2 {
    foo: "v2 value 1"
}
@v2 {
    foo: "v2 value 2"
}
class T2 {
    string name = "ballerina";
}

function init() {
    T1 a = {name: "John"};
    typedesc<any> t = typeof a;
    io:println(t.@v1 !is Annot); // @output false

    T1 b = {name: "John"};
    t = typeof b;
    io:println(t.@v2 !is ()); // @output false

    T2 c = new;
    t = typeof c;
    io:println(t.@v1 !is Annot); // @output false
    io:println(t.@v2 !is Annot[]); // @output false
    io:println(t.@v3 !is ()); // @output false
}

Test-Case: output
Description: Test member access expression as expression in type test expression.
Labels: is-expr, member-access-expr, module-type-decl, union-type, record-type, mapping-constructor-expr, int,
        float, string, boolean, optional-type, nil-type

type Type string|xml|boolean;

type Record1 record {|
    int|string a;
    float? b;
    int c?;
    boolean d = true;
    Type? e;
    string...;
|};

function init() {
    Record1 rec1 = {a: 1, b: (), "e": "A", "f": "B"};

    io:println(rec1["a"] !is int); // @output false
    io:println(rec1["b"]!is float); // @output true
    io:println(rec1["c"] !is int); // @output true
    io:println(rec1["d"] !is Type); // @output false
    io:println(rec1["e"] !is string); // @output false
    io:println(rec1["f"] !is string); // @output false
    io:println(rec1["g"] !is ()); // @output false
}

Test-Case: output
Description: Test function call expression as expression in type test expression.
Labels: is-expr, function-call-expr, module-const-decl, module-type-decl, string, nil-type, int, union-type,
        optional-type

const nm = "Anne Smith";

type Type string;

function init() {
    io:println(getName("Anne") !is string); // @output false
    io:println(getName("Anne") !is ()); // @output true
    io:println(getName("Anne") !is Type); // @output false
    io:println(getName("Anne") !is nm); // @output false
    io:println(getName("Anne") !is string|int); // @output false
}

function getName(string fname) returns string? {
    return fname + " Smith";
}

Test-Case: output
Description: Test method call expression as expression in type test expression.
Labels: is-expr, method-call-expr, module-class-decl, module-const-decl, module-type-decl, string, nil-type,
        int, union-type, optional-type

const nm = "Anne Smith";

type Type string;

class Person {
    function getName(string fname) returns string? {
        return fname + " Smith";
    }
}

function init() {
    Person p = new;
    io:println(p.getName("Anne") !is string); // @output false
    io:println(p.getName("Anne") !is ()); // @output true
    io:println(p.getName("Anne") !is Type); // @output false
    io:println(p.getName("Anne") !is nm); // @output false
    io:println(p.getName("Anne") !is string|int); // @output false
}

Test-Case: output
Description: Test error constructor expression as expression in type test expression.
Labels: is-expr, error-constructor-expr, module-type-decl, error-type, record-type, map-type, anydata, optional-type,
        any, union-type

type Record record {
    int code;
};

type ErrorType1 error<map<anydata>>;

type ErrorType2 error<Record>;

type ErrorType3 error<record {int no;}>;

type ErrorType4 ErrorType2 & ErrorType3;

type ErrorType5 distinct error<Record>;

type Type error?;

function init() {
    io:println(error("Err") !is error); // @output false
    io:println(error("Err") !is Type); // @output false
    io:println(error("Err") !is any|error); // @output false
    io:println(error("Err") !is ErrorType1); // @output false
    io:println(error("Err") !is ErrorType2); // @output true

    io:println(error("Err", error("AnotherErr")) !is error); // @output false
    io:println(error("Err", error("AnotherErr"), code = 1) !is ErrorType1); // @output false
    io:println(error("Err", error("AnotherErr"), code = 1) !is ErrorType2); // @output false
    io:println(error("message", error("AnotherErr"), code = 3, no = 1) !is ErrorType4); // @output false
    io:println(error("message", error("AnotherErr"), code = 3) !is ErrorType5); // @output true
}

Test-Case: output
Description: Test anonymous function expression as expression in type test expression.
Labels: is-expr, anonymous-function-expr, string, int, union-type, function-type

function init() {
    io:println(function(string x, string y) returns (string) {
        return x + y;
    } !is function); // @output false

    io:println(function(string x, string y) returns (string) {
        return x + y;
    } !is function (string, string) returns (string)); // @output false

    io:println(function(string x, string y) returns (string) {
        return x + y;
    } !is function (string, string|int) returns (string)); // @output true

    io:println(function(string x, string y) returns (string) {
        return x + y;
    } !is function (string, string) returns (string|int)); // @output false
}

Test-Case: output
Description: Test let expression as expression in type test expression.
Labels: is-expr, let-expr, moduel-const-decl, int, string, float, decimall,  union-type, map-type,
        array-constructor-expr, mapping-constructor-expr, member-access-expr

const ONE = 1;

function init() {
    io:println(let int i = 2, float f = 2.2f, decimal d = 1.2d in <decimal>i + <decimal>f + d !is decimal); // @output false
    io:println(let var l = ["A", 2] in l[0] !is string); // @output false
    io:println(let map<int|string> m = {a: 1, b: "A"} in m["a"] !is int); // @output false
    io:println(let map<int|string> m = {a: 1, b: "A"} in m["a"] !is ONE); // @output false
}

Test-Case: output
Description: Test type cast expression as expression in type test expression.
Labels: is-expr, type-cast-expr, int, string, decimal, module-const-decl, union-type

const ONE = 1;

type Type int|float;

function init() {
    io:println(<decimal>2 !is decimal); // @output false

    int|string a = 1;
    io:println(<int>a !is ONE); // @output false
    io:println(<int>a !is Type); // @output false
}

Test-Case: output
Description: Test type of expression as expression in type test expression.
Labels: is-expr, typeof-expr, int, string, module-const-decl, union-type

const ONE = 1;

function init() {
    io:println(typeof 2 !is typedesc<int>); // @output false
    io:println(typeof 2 !is typedesc<int|string>); // @output false

    int|string a = 1;
    io:println(typeof a !is typedesc<ONE>); // @output false
    io:println(typeof a !is typedesc<int>); // @output false
}

Test-Case: output
Description: Test unary logical expression as expression in type test expression.
Labels: is-expr, unary-logical-expr, module-const-decl, boolean, relational-expr, equality-expr, int, string,
        union-type

const TRUE = true;

function init() {
    io:println(!true !is boolean); // @output false
    io:println(!true !is true); // @output true
    io:println(!true !is false); // @output false

    int a = 10;
    io:println(!(a < 5) !is true); // @output false
    io:println(!(a < 5) !is false); // @output true

    io:println(!(a == 5) !is true); // @output false
    io:println(!(a == 5) !is false); // @output true

    string|int b = 10;
    io:println(!(b !is int) !is true); // @output false
    io:println(!(b !is int) !is false); // @output true

    io:println(!TRUE !is true); // @output true
    io:println(!TRUE !is false); // @output false
}

Test-Case: output
Description: Test unary numeric expression as expression in type test expression.
Labels: is-expr, module-const-decl, module-type-decl, int, unary-minus, unary-plus, unary-complement, anydata

const FIVE = 5;

type Type int;

function init() {
    io:println(+5 !is FIVE); // @output false
    io:println(+5 !is int); // @output false

    io:println(-5 !is Type); // @output false
    io:println(-5 !is -5); // @output false

    io:println(~5 !is -6); // @output false
    io:println(~5 !is anydata); // @output false
}

Test-Case: output
Description: Test multiplicative expression as expression in type test expression.
Labels: is-expr, module-const-decl, module-type-decl, int, multiplicative-expr, anydata

const FIVE = 5;

type Type int;

function init() {
    io:println(1 * 5 !is FIVE); // @output false
    io:println(1 * 5 !is int); // @output false

    io:println(4 / 2 !is 2); // @output false
    io:println(4 / 2 !is Type); // @output false

    io:println(5 % 2 !is 1); // @output false
    io:println(5 % 2 !is anydata); // @output false
}

Test-Case: output
Description: Test additive expression as expression in type test expression.
Labels: is-expr, module-const-decl, module-type-decl, int, additive-expr, anydata

const FIVE = 5;

type Type int;

function init() {
    io:println(2 + 3 !is FIVE); // @output false
    io:println(2 - 3 !is int); // @output false

    io:println(4 - 2 !is 2); // @output false
    io:println(4 - 2 !is Type); // @output false
}

Test-Case: output
Description: Test shift expression as expression in type test expression.
Labels: is-expr, module-const-decl, module-type-decl, int, string, union-type, shift-expr

const ONE = 1;

type Type int;

function init() {
    io:println(4 << 2 !is 16); // @output false
    io:println(4 << 2 !is int); // @output false

    io:println(4 >> 2 !is ONE); // @output false
    io:println(4 >> 2 !is Type); // @output false

    io:println(8 >>> 2 !is 2|4); // @output false
    io:println(8 >>> 2 !is int|string); // @output false
}

Test-Case: output
Description: Test binary bitwise expression as expression in type test expression.
Labels: is-expr, module-const-decl, module-type-decl, int, string, union-type, binary-bitwise-expr

const SIX = 6;

type Type int;

function init() {
    io:println((4 & 2) !is 0); // @output false
    io:println((4 & 2) !is int); // @output false

    io:println((4 | 2) !is SIX); // @output false
    io:println((4 | 2) !is Type); // @output false

    io:println((4 ^ 2) !is SIX); // @output false
    io:println((4 ^ 2) !is int|string); // @output false
}

Test-Case: output
Description: Test range expression as expression in type test expression.
Labels: is-expr, module-type-decl, object-type, record-type, range-expr

type Object1 object {
    public function iterator() returns (object {
        public function next() returns (record {|int value;|}?);
    });
};

type Record record {|
    int value;
|};

public type Object object {
    public function next() returns (Record?);
};

type Object2 object {
    public function iterator() returns Object;
};

function init() {
    io:println(1 ... 5 !is object {
        public isolated function iterator() returns (object {
            public isolated function next() returns (record {|int value;|}?);
        });
    }); // @output false

    io:println(1 ... 5 !is Object1); // @output false
    io:println(1 ... 5 !is Object2); // @output false

    io:println(1 ..< 5 !is object {
        public isolated function iterator() returns (object {
            public isolated function next() returns (record {|int value;|}?);
        });
    }); // @output false

    io:println(1 ..< 5 !is Object1); // @output false
    io:println(1 ..< 5 !is Object2); // @output false
}

Test-Case: output
Description: Test relational expression as expression in type test expression.
Labels: is-expr, module-const-decl, int, relational-expr, boolean

const TRUE = true;

function init() {
    int a = 5;

    io:println(a < 10 !is boolean); // @output false
    io:println(a < 10 !is true); // @output false
    io:println(a < 10 !is TRUE); // @output false

    io:println(a <= 10 !is boolean); // @output false
    io:println(a <= 10 !is true); // @output false
    io:println(a <= 10 !is TRUE); // @output false

    io:println(a > 10 !is boolean); // @output false
    io:println(a > 10 !is true); // @output true
    io:println(a > 10 !is TRUE); // @output true

    io:println(a >= 10 !is boolean); // @output false
    io:println(a >= 10 !is true); // @output true
    io:println(a >= 10 !is TRUE); // @output true
}

Test-Case: output
Description: Test type test expression as expression in type test expression.
Labels: is-expr, module-const-decl, int, optional-type, boolean

const TRUE = true;

function init() {
    int? a = 5;

    io:println(a !is int !is boolean); // @output false
    io:println(a !is int !is true); // @output true
    io:println(a !is int !is TRUE); // @output true
}

Test-Case: output
Description: Test equality expression as expression in type test expression.
Labels: is-expr, module-const-decl, int, equality-expr, boolean

const TRUE = true;

function init() {
    int a = 5;

    io:println((a == 5) !is boolean); // @output false
    io:println((a == 5) !is true); // @output false
    io:println((a == 5) !is TRUE); // @output false

    io:println((a != 5) !is boolean); // @output false
    io:println((a != 5) !is true); // @output true
    io:println((a != 5) !is TRUE); // @output true

    io:println((a === 5) !is boolean); // @output false
    io:println((a === 5) !is true); // @output false
    io:println((a === 5) !is TRUE); // @output false

    io:println((a !== 5) !is boolean); // @output false
    io:println((a !== 5) !is true); // @output true
    io:println((a !== 5) !is TRUE); // @output true
}

Test-Case: output
Description: Test logical expression as expression in type test expression.
Labels: is-expr, module-const-decl, logical-expr, boolean, relational-expr

const TRUE = true;

function init() {
    boolean a = true;

    io:println((TRUE && a) !is boolean); // @output false
    io:println((1 < 10 && 2 > 1) !is TRUE); // @output false

    io:println((false || a) !is boolean); // @output false
    io:println((1 < 10 || 2 > 3) !is TRUE); // @output false
}

Test-Case: output
Description: Test conditional expression as expression in type test expression.
Labels: is-expr, module-const-decl, conditional-expr, int, optional-type

const ONE = 1;

function init() {
    int? a = 5;

    io:println((a !is int ? 1 : 2) !is 1); // @output true
    io:println((a !is int ? 1 : 2) !is ONE); // @output true
    io:println((a !is int ? 1 : 2) !is int); // @output false
    io:println((a !is int ? 1 : 2) !is 1|0); // @output true
}

Test-Case: output
Description: Test checking expression as expression in type test expression.
Labels: is-expr, check, checkpanic, module-const-decl, int, error, union-type

const ONE = 1;

function init() returns error? {
    int|error a = 1;

    io:println(check a !is 1); // @output false
    io:println(check a !is ONE); // @output false
    io:println(check a !is int); // @output false
    io:println(check a !is 1|0); // @output false

    io:println(checkpanic a !is 1); // @output false
    io:println(checkpanic a !is ONE); // @output false
    io:println(checkpanic a !is int); // @output false
    io:println(checkpanic a !is 1|0); // @output false
}

Test-Case: output
Description: Test trap expression as expression in type test expression.
Labels: is-expr, trap-expr, module-const-decl, int, error, union-type

const ONE = 1;

function init() {
    int|error a = 1;

    io:println(trap a !is 1); // @output false
    io:println(trap a !is ONE); // @output false
    io:println(trap a !is int); // @output false
    io:println(trap a !is 1|0); // @output false
    io:println(trap a !is error); // @output true
}

Test-Case: output
Description: Test query expression as expression in type test expression.
Labels: is-expr, query-expr, array-type, tuple-type, int, list-constructor-expr

function init() {
    int[] arr = [1, 2, 3, 4, 5];
    io:println((from int i in arr
        select i * 10) !is int[]); // @output false
    io:println((from int i in arr
        select i * 10) !is [int...]); // @output false
    io:println((from int i in arr
        select i * 10) !is [int, int, int, int, int, int...]); // @output true
}

Test-Case: output
Description: Test xml navigate expression as expression in type test expression.
Labels: is-expr, xml-navigate-expr, xml:Element, xml:Text, xml:Comment, xml:ProcessingInstruction

function init() {
    xml x1 = xml `<root><child attr="attr-val"></child></root><root><child attr="attr-val2"></child></root>`;
    io:println(x1.<root> !is xml:Element); // @output true
    io:println(x1.<root> !is xml<xml:Element>); // @output false

    io:println(x1/<child> !is xml:Element); // @output true
    io:println(x1/<child> !is xml<xml:Element>); // @output false
    io:println(x1/<child> !is xml<xml:Element|xml:Text|xml:Comment|xml:ProcessingInstruction>); // @output false
}

Test-Case: output
Description: Test transactional expression as expression in type test expression.
Labels: is-expr, transactional-expr, module-const-decl, transaction-stmt, commit-stmt, check, error, optional-type

const TRUE = true;

function init() returns error? {
    transaction {
        io:println(transactional !is true); // @output false
        io:println(transactional !is TRUE); // @output false
        check commit;
    }
}

Test-Case: output
Description: Test simple type as type descriptor in type test expression.
Labels: is-expr, boolean, int, float, decimal, nil-type, any, nil-literal, boolean-literal, DecimalNumber,
        DecimalFloatingPointNumber, int:Signed32, int:Signed16, int:Signed8, int:Unsigned32, int:Unsigned16,
        int:Unsigned8

function init() {
    any a = ();
    io:println(a !is ()); // @output false
    io:println(a !is null); // @output false

    a = true;
    io:println(a !is boolean); // @output false

    a = 10;
    io:println(a !is int); // @output false
    io:println(a !is int:Signed32); // @output false
    io:println(a !is int:Signed16); // @output false
    io:println(a !is int:Signed8); // @output false
    io:println(a !is int:Unsigned32); // @output false
    io:println(a !is int:Unsigned16); // @output false
    io:println(a !is int:Unsigned8); // @output false

    a = 10f;
    io:println(a !is float); // @output false

    a = 10d;
    io:println(a !is decimal); // @output false
}

Test-Case: output
Description: Test sequence type as type descriptor in type test expression.
Labels: is-expr, string, string:Char, any, xml, xml:Element, xml:Comment, xml:Text, xml:ProcessingInstruction

function init() {
    any a = "A";
    io:println(a !is string); // @output false
    io:println(a !is string:Char); // @output false

    a = xml `<book><author>Enid Blyton</author></book>`;
    io:println(a !is xml); // @output false
    io:println(a !is xml:Element); // @output false
    io:println(a !is xml<xml:Element>); // @output false

    a = xml `<!--Th!is !is a comment-->`;
    io:println(a !is xml); // @output false
    io:println(a !is xml:Comment); // @output false
    io:println(a !is xml<xml:Comment>); // @output false
    io:println(a !is xml<xml:Element>); // @output true

    a = xml `Th!is !is a Text`;
    io:println(a !is xml); // @output false
    io:println(a !is xml:Text); // @output false
    io:println(a !is xml<xml:Text>); // @output false
    io:println(a !is xml<xml:Element>); // @output true

    a = xml `<?xml-stylesheet type="text/xsl" href="style.xsl"?>`;
    io:println(a !is xml); // @output false
    io:println(a !is xml:ProcessingInstruction); // @output false
    io:println(a !is xml<xml:ProcessingInstruction>); // @output false
    io:println(a !is xml<xml:Element>); // @output true
}

Test-Case: output
Description: Test list type as type descriptor in type test expression.
Labels: is-expr, array-type, tuple-type, list-constructor-expr, any, anydata, int, string, float, union-type

function init() {
    io:println([1, 2, 3] !is int[]); // @output false
    io:println([1, 2, 3] !is [int, int, int]); // @output false
    io:println([1, 2, 3] !is [int, int, int...]); // @output false
    io:println([1, 2, 3] !is [int, int...]); // @output false
    io:println([1, 2, 3] !is [int...]); // @output false

    io:println([1, "A", 3f] !is (int|string|float)[]); // @output false
    io:println([1, "A", 3f] !is [int|string|float...]); // @output false
    io:println([1, "A", 3f] !is [int, string, float]); // @output false
    io:println([1, "A", 3f] !is [int, string, float...]); // @output false
    io:println([1, "A", 3f] !is [int, string|float...]); // @output false
    io:println([1, "A", 3f] !is any[]); // @output false
    io:println([1, "A", 3f] !is anydata[]); // @output false
    io:println([1, "A", 3f] !is [anydata, anydata, anydata]); // @output false
}

Test-Case: output
Description: Test map type as type descriptor in type test expression.
Labels: is-expr, module-type-decl, record-type, map-type, int, string, union-type

type Record1 record {|
    int x;
    int y;
|};

type Record2 record {
    int x;
    int y;
};

type Record3 record {|
    int x;
    int y;
    string...;
|};

function init() {
    var a = {x: 1, y: 2};

    io:println(a !is map<int>); // @output false
    io:println(a !is map<int|string>); // @output false
    io:println(a !is record {int x; int y;}); // @output false
    io:println(a !is record {|int x; int y;|}); // @output false
    io:println(a !is record {|int x; int y;string...; |}); // @output false
    io:println(a !is record {|int x; int y; string z?;|}); // @output false
    io:println(a !is record {int x; int y; string z?;}); // @output false
    io:println(a !is Record1); // @output false
    io:println(a !is Record2); // @output false
    io:println(a !is Record3); // @output false

    Record3 b = {x: 1, y: 2, "u": "A", "v": "B"};
    Record3 { x: x1, ...rest1 } = b;
    var { x: x2, y: y2, ...rest2 } = b;

    io:println(rest1 !is record{|never x?; int y; string...;|}); // @output false
    io:println(rest1 !is map<int|string>); // @output false
    io:println(rest2 !is record{|string...;|}); // @output false
    io:println(rest2 !is map<string>); // @output false
}

Test-Case: output
Description: Test table type as type descriptor in type test expression.
Labels: is-expr, module-type-decl, record-type, readonly-type, map-type, table-type, int, float, string, union-type,
        anydata

type Record record {|
    readonly int x;
    float y;
    string...;
|};

type TableType1 table<Record> key(x);

function init() {
    TableType1 t1 = table [{x: 1, y: 2f, "u": "A", "v": "B"}];

    io:println(t1 !is table<record {|int x; float y;string...; |}>); // @output false
    io:println(t1 !is table<map<int|float|string>>); // @output false
    io:println(t1 !is table<record {|readonly int x; float y; string...; |}> key(x)); // @output false
    io:println(t1 !is table<record {|anydata...;|}>); // @output false
}


Test-Case: output
Description: Test union type as type descriptor in type test expression.
Labels: is-expr, union-type, int, string, map-type, any, error-type

function init() {
    io:println(2 !is int|string); // @output false
    io:println("A" !is any|error); // @output false
    io:println({a: 1, b: 2} !is map<int>|map<string>); // @output false
    io:println({a: 1, b: 1} !is map<1>|map<2>); // @output true
}

Test-Case: output
Description: Test future type as type descriptor in type test expression.
Labels: is-expr, module-type-decl, record-type, future-type, int, string, union-type, array-type, function-call-expr,
        start-action, additive-expr, list-constructor-expr, mapping-constructor-expr

type Foo record {
    int i;
};

function init() {
    var a = start add(5, 2);

    io:println(a !is future); // @output false
    io:println(a !is future<int>); // @output false
    io:println(a !is future<int|string>); // @output false

    var b = start intArray();

    io:println(b !is future); // @output false
    io:println(b !is future<int[]>); // @output false

    var c = start getFoo();

    io:println(c !is future<Foo>); // @output false
    io:println(c !is future<record {}>); // @output false
    io:println(c !is future<int|Foo>); // @output false
    io:println(c !is future<record {}|int[]>); // @output false
}

function add(int i, int j) returns int {
    int k = i + j;
    return k;
}

function intArray() returns int[] {
    int[] j = [1, 2, 3];
    return j;
}

function getFoo() returns Foo => {i: 1, "j": "hello"};

Test-Case: output
Description: Test handle type as type descriptor in type test expression.
Labels: is-expr, handle-type, optional-type, nil-literal

function init() {
    handle? h = ();
    io:println(h !is handle); // @output true
}

Test-Case: output
Description: Test stream type as type descriptor in type test expression.
Labels: is-expr, module-class-decl, explicit-new-expr, module-type-decl, stream-type, error, optional-type, union-type,
        int, nil-type

class Class {
    public isolated function next() returns record {|int value;|}|error? {
        return {value: 1};
    }
}

class Class2 {
    public isolated function next() returns record {|int value;|}? {
        return {value: 1};
    }
}

type CompletionType error?;

type IntType int|string;

function init() {
    Class cls = new ();
    stream<int, error?> a = new (cls);
    io:println(a !is stream<int, string|error?>); // @output false
    io:println(a !is stream<IntType, CompletionType>); // @output false
    io:println(a !is stream<IntType, CompletionType>); // @output false

    Class2 cls2 = new ();
    stream<int> b = new (cls2);
    io:println(b !is stream<int>); // @output false
    io:println(b !is stream<int, ()>); // @output false
    io:println(b !is stream<IntType>); // @output false
    io:println(b !is stream<IntType, CompletionType>); // @output false
}

Test-Case: output
Description: Test singleton type as type descriptor in type test expression.
Labels: is-expr, singleton-type, module-const-decl, int, string, float, const-reference-expr

const TEN = 10;
const A = "A";
const FLOAT = 10f;

function init() {
    int a = 10;
    io:println(a !is 10); // @output false
    io:println(a !is 20); // @output true
    io:println(a !is TEN); // @output false

    string b = "A";
    io:println(b !is "A"); // @output false
    io:println(b !is "B"); // @output true
    io:println(b !is A); // @output false

    float c = 10;
    io:println(c !is 10f); // @output false
    io:println(c !is 20f); // @output true
    io:println(c !is FLOAT); // @output false
}

Test-Case: output
Description: Test any type as type descriptor in type test expression.
Labels: is-expr, module-type-decl, int, string, float, decimal, boolean, union-type, any, map-type, table-type,
        record-type, type-reference, error, mapping-constructor-expr, table-constructor-expr, error-constructor-expr

type Type int|string|float|decimal|boolean;

function init() {
    int a = 10;
    io:println(a !is any); // @output false

    Type b = 10;
    io:println(b !is any); // @output false

    int|error c = error("Error");
    io:println(c !is any); // @output true

    map<string> d = {a: "A", b: "B", c: "C"};
    io:println(d !is any); // @output false

    map<string|error> e = {a: "A", b: "B", c: "C"};
    io:println(e !is any); // @output false

    map<string|error> f = {a: "A", b: "B", c: error("error")};
    io:println(f !is any); // @output false

    table<record {|readonly int a; string b;|}> g = table [{a: 1, b: "B"}];
    io:println(g !is any); // @output false

    table<record {|readonly int a; string b;|}> h = table key(a) [
            {a: 1, b: "B"},
            {a: 2, b: "C"}
        ];
    io:println(h !is any); // @output false

    table<record {|readonly int a; error b;|}> i = table key(a) [
            {a: 1, b: error("E1")},
            {a: 2, b: error("E2")}
        ];
    io:println(i !is any); // @output false

    table<map<int|error>> j = table key(a) [
            {a: 1, b: error("E1")},
            {a: 2, b: error("E2")}
        ];
    io:println(j !is any); // @output false
}

Test-Case: output
Description: Test readonly type as type descriptor in type test expression.
Labels: is-expr, module-type-decl, module-class-decl, record-type, readonly-type, intersection-type, map-type,
        mapping-constructor-expr

type Details record {|
    string name;
    int yob;
|};

type Department record {
    string name = "IT";
};

readonly class Employee {
    Details details;
    Department dept;
    int id;

    function init(Details & readonly details, Department & readonly dept, int id) {
        self.details = details;
        self.dept = dept;
        self.id = id;
    }

    function getId() returns int {
        return self.id;
    }
}

type Student record {
    readonly string name;
    readonly int id?;
};

function init() {
    Employee emp = new ({name: "Jo", yob: 2000}, {}, 1234);

    io:println(emp !is readonly); // @output false
    io:println(emp.details !is readonly); // @output false
    io:println(emp.details !is Details & readonly); // @output false
    io:println(emp.dept !is readonly); // @output false
    io:println(emp.dept !is Department & readonly); // @output false

    readonly a = 10;
    io:println(a !is readonly); // @output false

    string b = "ballerina";
    io:println(b !is readonly); // @output false

    map<int> & readonly c = {
        math: 80,
        physics: 85,
        chemistry: 75
    };
    io:println(c !is readonly); // @output false

    Student std = {
        name: "Anne"
    };
    io:println(std.name !is readonly); // @output false
    io:println(std.id !is readonly); // @output false
    io:println(std?.id !is readonly); // @output false
    io:println(std["name"] !is readonly); // @output false
}

Test-Case: output
Description: Test distinct type as type descriptor in type test expression.
Labels: is-expr, module-class-decl, module-type-decl, object-type, object-constructor-expr, explicit-new-expr

type Object1 distinct object {
    int a;
    function f1();
};

distinct class Class1 {
    int i = 0;
}

distinct class Class2 {
    *Class1;

    function init(int i) {
        self.i = i;
    }
}

function init() {
    Object1 c = object {
        int a = 10;
        function f1() {

        }
    };
    io:println(c !is distinct Object1); // @output false

    Class1 d = new;
    io:println(d !is distinct Class1); // @output false

    Class2 e = new(1);
    io:println(e !is distinct Class1); // @output false
    io:println(e !is distinct Class2); // @output false
}

Test-Case: output
Description: Test distinct type as type descriptor in type test expression.
Fail-Issue:
Labels: is-expr, module-type-decl, object-type, object-constructor-expr

type Obj1 distinct object {
    int a;
    function f1();
};

function init() {
    Obj1 c = object {
        int a = 10;
        function f1() {

        }
    };
    io:println(c !is distinct object {
        int a;
        function f1();
    }); // @output false
}

Test-Case: output
Description: Test distinct type as type descriptor in type test expression.
Fail-Issue:
Labels: is-expr, module-type-decl, error-type, error-constructor-expr

type Error0 distinct error;

type Error1 distinct error<map<int>>;

function init() {
    Error0 a = error("E0");
    io:println(a !is distinct error); // @output false

    Error1 b = error("E1", a = 1);
    io:println(b !is distinct error); // @output false
}

Test-Case: output
Description: Test intersection type as type descriptor in type test expression.
Labels: is-expr, module-type-decl, readonly-type, intersection-type, array-type, union-type, optional-type,
        mapping-constructor-expr, list-constructor-expr, json-type, anydata

type Record1 record {
    int i;
};

type ReadOnlyRecord1 readonly & Record1;

type ArrayTypes int[]|string[];

type Record2 record {|
    (ArrayTypes & readonly)? j;
|};

function init() {
    ReadOnlyRecord1 a = {i: 1, "j": "A"};
    Record1 b = a;
    io:println(b !is ReadOnlyRecord1); // @output false
    io:println(b !is Record1 & readonly); // @output false

    Record1? & readonly c = {i: 100};
    io:println(c !is ReadOnlyRecord1); // @output false
    io:println(c !is Record1 & readonly); // @output false

    Record2 & readonly d = {j: [1, 2, 3]};
    io:println(d.j !is int[] & readonly); // @output false

    Record2 & readonly e = {j: ()};
    io:println(e.j !is int[]? & readonly); // @output false

    Record2 & readonly f = {j: ["A", "B", "C"]};
    io:println(f.j !is string[] & readonly); // @output false

    map<json> & readonly g = {
        a: 1,
        b: "foo",
        c: null,
        d: {
            a1: null,
            b1: true
        }
    };
    io:println(g["a"] !is int & readonly); // @output false
    io:println(g["c"] !is readonly); // @output false
    io:println(g["d"] !is map<anydata> & readonly); // @output false
}

Test-Case: output
Description: Test json type as type descriptor in type test expression.
Labels: is-expr, module-type-decl, record-type, mapping-constructor-expr, json-type, string, int, decimal, float,
        union-type, map-type, member-access-expr

type Record1 record {
    int i;
};

function init() {
    Record1 a = {i: 100};
    io:println(a !is json); // @output true
    io:println(a.i !is json); // @output false

    string? b = "ABC";
    io:println(b !is json); // @output false

    int|string|decimal|float c = "ABC";
    io:println(c !is json); // @output false

    map<json> d = {
        a: 1,
        b: "foo",
        c: null,
        d: {
            a1: null,
            b1: true
        }
    };
    io:println(d !is json); // @output false
    io:println(d["a"] !is json); // @output false
    io:println(d["b"] !is json); // @output false
    io:println(d["c"] !is json); // @output false
    io:println(d["d"] !is json); // @output false
}

Test-Case: output
Description: Test byte type as type descriptor in type test expression.
Labels: is-expr, byte, int, array-type, list-constructor-expr, int:Signed32, int:Signed16, int:Unsigned32,
        int:Unsigned16, int:Unsigned8, union-type

function init() {
    int a = 10;
    io:println(a !is byte); // @output false

    int[] b = [1, 2, 3];
    io:println(b[2] !is byte); // @output false

    int:Signed32 c = 10;
    io:println(c !is byte); // @output false

    int:Signed16 d = 10;
    io:println(d !is byte); // @output false

    int:Unsigned32 e = 10;
    io:println(e !is byte); // @output false

    int:Unsigned16 f = 10;
    io:println(f !is byte); // @output false

    int:Unsigned16 g = 10;
    io:println(g !is byte); // @output false

    int:Unsigned8 h = 10;
    io:println(h !is byte); // @output false

    int:Unsigned16|int:Signed8 i = 10;
    io:println(i !is byte); // @output false
}

Test-Case: output
Description: Test type reference as type descriptor in type test expression.
Labels: is-expr, module-const-decl, int, string, union-type, record-type, table-type, mapping-constructor-expr,

const ONE = 1;
const JOHN = "john";

type A int|string;

type B ONE|JOHN;

type C record {|
    string...;
|};

type D record {
    readonly string a;
    string b;
    string c?;
};

type E table<D>;

type F table<D> key(a);

type G table<D> key<string>;

function init() {
    io:println(1 !is A); // @output false
    io:println("Mike" !is B); // @output true

    record {|string a; string b;|} a = {a: "A", b: "B"};
    io:println(a !is C); // @output false
    io:println(a !is D); // @output true

    io:println(table key(a) [{a: "A", b: "B"}] !is E); // @output false

    F b = table [{a: "A", b: "B"}];
    io:println(b !is E); // @output false
    io:println(b !is G); // @output false
}

Test-Case: output
Description: Test using type test expression in if else statement.
Labels: is-expr, module-type-decl, record-type, readonly-type, mapping-constructor-expr, if-else-stmt, union-type

type A record {|
    string a;
|};

type B record {|
    int a;
|};

type C A|B;

type D readonly & record {|
    int i;
|};

type E readonly & record {|
    string i;
|};

type F D|E;

function init() {
    io:println(f1({a: 1})); // @output 2
    io:println(f2({a: 1})); // @output 1
    io:println(f3({i: "A"})); // @output 3
    io:println(f4({i: "A"})); // @output 3
}

function f1(A|B x) returns int {
    if x !is B {
        return 1;
    }
    return 2;
}

function f2(C x) returns int {
    if x !is A {
        return 1;
    }
    return 2;
}

function f3(F x) returns int {
    if x !is D {
        return 3;
    }
    return 4;
}

function f4(D|E x) returns int {
    if x !is D {
        return 3;
    }
    return 4;
}

Test-Case: output
Description: Test inferring the type of the result of type test expression with var.
Labels: is-expr, var, DecimalNumber, int

function init() {
    var a = 1 !is int;
    boolean b = a;
    io:println(b); // @output false
}

Test-Case: output
Description: Test type test expression at module level.
Labels: is-expr, int, boolean, DecimalNumber

boolean b = 1 !is int;

function init() {
    io:println(b); // @output false
}

Test-Case: error
Description: Test assigning the result of type test expression to an incompatible type.
Labels: is-expr, int, DecimalNumber

function init() {
    int _ = 1 !is int; // @error expected 'int', found 'boolean'
}

Test-Case: error
Description: Test using an unknown type as the type descriptor.
Labels: is-expr, boolean, DecimalNumber

function errorFunction() {
    boolean _ = 1 !is expr; // @error unknown type 'expr'
}
